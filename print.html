<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Scala Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> introduction.md</a></li><li class="chapter-item expanded "><a href="prelude-taste-of-scala.html"><strong aria-hidden="true">2.</strong> prelude-taste-of-scala.md</a></li><li class="chapter-item expanded "><a href="preliminaries.html"><strong aria-hidden="true">3.</strong> preliminaries.md</a></li><li class="chapter-item expanded "><a href="scala-features.html"><strong aria-hidden="true">4.</strong> scala-features.md</a></li><li class="chapter-item expanded "><a href="hello-world-1.html"><strong aria-hidden="true">5.</strong> hello-world-1.md</a></li><li class="chapter-item expanded "><a href="hello-world-2.html"><strong aria-hidden="true">6.</strong> hello-world-2.md</a></li><li class="chapter-item expanded "><a href="scala-repl.html"><strong aria-hidden="true">7.</strong> scala-repl.md</a></li><li class="chapter-item expanded "><a href="two-types-variables.html"><strong aria-hidden="true">8.</strong> two-types-variables.md</a></li><li class="chapter-item expanded "><a href="type-is-optional.html"><strong aria-hidden="true">9.</strong> type-is-optional.md</a></li><li class="chapter-item expanded "><a href="built-in-types.html"><strong aria-hidden="true">10.</strong> built-in-types.md</a></li><li class="chapter-item expanded "><a href="two-notes-about-strings.html"><strong aria-hidden="true">11.</strong> two-notes-about-strings.md</a></li><li class="chapter-item expanded "><a href="command-line-io.html"><strong aria-hidden="true">12.</strong> command-line-io.md</a></li><li class="chapter-item expanded "><a href="control-structures.html"><strong aria-hidden="true">13.</strong> control-structures.md</a></li><li class="chapter-item expanded "><a href="if-then-else-construct.html"><strong aria-hidden="true">14.</strong> if-then-else-construct.md</a></li><li class="chapter-item expanded "><a href="for-loops.html"><strong aria-hidden="true">15.</strong> for-loops.md</a></li><li class="chapter-item expanded "><a href="for-expressions.html"><strong aria-hidden="true">16.</strong> for-expressions.md</a></li><li class="chapter-item expanded "><a href="match-expressions.html"><strong aria-hidden="true">17.</strong> match-expressions.md</a></li><li class="chapter-item expanded "><a href="try-catch-finally.html"><strong aria-hidden="true">18.</strong> try-catch-finally.md</a></li><li class="chapter-item expanded "><a href="classes.html"><strong aria-hidden="true">19.</strong> classes.md</a></li><li class="chapter-item expanded "><a href="classes-aux-constructors.html"><strong aria-hidden="true">20.</strong> classes-aux-constructors.md</a></li><li class="chapter-item expanded "><a href="constructors-default-values.html"><strong aria-hidden="true">21.</strong> constructors-default-values.md</a></li><li class="chapter-item expanded "><a href="methods-first-look.html"><strong aria-hidden="true">22.</strong> methods-first-look.md</a></li><li class="chapter-item expanded "><a href="enumerations-pizza-class.html"><strong aria-hidden="true">23.</strong> enumerations-pizza-class.md</a></li><li class="chapter-item expanded "><a href="traits-intro.html"><strong aria-hidden="true">24.</strong> traits-intro.md</a></li><li class="chapter-item expanded "><a href="traits-interfaces.html"><strong aria-hidden="true">25.</strong> traits-interfaces.md</a></li><li class="chapter-item expanded "><a href="traits-abstract-mixins.html"><strong aria-hidden="true">26.</strong> traits-abstract-mixins.md</a></li><li class="chapter-item expanded "><a href="abstract-classes.html"><strong aria-hidden="true">27.</strong> abstract-classes.md</a></li><li class="chapter-item expanded "><a href="collections-101.html"><strong aria-hidden="true">28.</strong> collections-101.md</a></li><li class="chapter-item expanded "><a href="arraybuffer-examples.html"><strong aria-hidden="true">29.</strong> arraybuffer-examples.md</a></li><li class="chapter-item expanded "><a href="list-class.html"><strong aria-hidden="true">30.</strong> list-class.md</a></li><li class="chapter-item expanded "><a href="vector-class.html"><strong aria-hidden="true">31.</strong> vector-class.md</a></li><li class="chapter-item expanded "><a href="map-class.html"><strong aria-hidden="true">32.</strong> map-class.md</a></li><li class="chapter-item expanded "><a href="set-class.html"><strong aria-hidden="true">33.</strong> set-class.md</a></li><li class="chapter-item expanded "><a href="anonymous-functions.html"><strong aria-hidden="true">34.</strong> anonymous-functions.md</a></li><li class="chapter-item expanded "><a href="collections-methods.html"><strong aria-hidden="true">35.</strong> collections-methods.md</a></li><li class="chapter-item expanded "><a href="collections-maps.html"><strong aria-hidden="true">36.</strong> collections-maps.md</a></li><li class="chapter-item expanded "><a href="misc.html"><strong aria-hidden="true">37.</strong> misc.md</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">38.</strong> tuples.md</a></li><li class="chapter-item expanded "><a href="oop-pizza-example.html"><strong aria-hidden="true">39.</strong> oop-pizza-example.md</a></li><li class="chapter-item expanded "><a href="sbt-scalatest-intro.html"><strong aria-hidden="true">40.</strong> sbt-scalatest-intro.md</a></li><li class="chapter-item expanded "><a href="scala-build-tool-sbt.html"><strong aria-hidden="true">41.</strong> scala-build-tool-sbt.md</a></li><li class="chapter-item expanded "><a href="sbt-scalatest-tdd.html"><strong aria-hidden="true">42.</strong> sbt-scalatest-tdd.md</a></li><li class="chapter-item expanded "><a href="sbt-scalatest-bdd.html"><strong aria-hidden="true">43.</strong> sbt-scalatest-bdd.md</a></li><li class="chapter-item expanded "><a href="functional-programming.html"><strong aria-hidden="true">44.</strong> functional-programming.md</a></li><li class="chapter-item expanded "><a href="pure-functions.html"><strong aria-hidden="true">45.</strong> pure-functions.md</a></li><li class="chapter-item expanded "><a href="passing-functions-around.html"><strong aria-hidden="true">46.</strong> passing-functions-around.md</a></li><li class="chapter-item expanded "><a href="no-null-values.html"><strong aria-hidden="true">47.</strong> no-null-values.md</a></li><li class="chapter-item expanded "><a href="companion-objects.html"><strong aria-hidden="true">48.</strong> companion-objects.md</a></li><li class="chapter-item expanded "><a href="case-classes.html"><strong aria-hidden="true">49.</strong> case-classes.md</a></li><li class="chapter-item expanded "><a href="case-objects.html"><strong aria-hidden="true">50.</strong> case-objects.md</a></li><li class="chapter-item expanded "><a href="functional-error-handling.html"><strong aria-hidden="true">51.</strong> functional-error-handling.md</a></li><li class="chapter-item expanded "><a href="concurrency-signpost.html"><strong aria-hidden="true">52.</strong> concurrency-signpost.md</a></li><li class="chapter-item expanded "><a href="futures.html"><strong aria-hidden="true">53.</strong> futures.md</a></li><li class="chapter-item expanded "><a href="where-next.html"><strong aria-hidden="true">54.</strong> where-next.md</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Scala Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<h2>type: chapter
layout: multipage-overview
title: Introduction
description: An introduction to the Scala Book
partof: scala_book
overview-name: Scala Book
num: 1
outof: 54
next-page: prelude-taste-of-scala</h2>
<p>In these pages, <em>Scala Book</em> provides a quick introduction and overview of the Scala programming language. The book is written in an informal style, and consists of more than 50 small lessons. Each lesson is long enough to give you an idea of how the language features in that lesson work, but short enough that you can read it in fifteen minutes or less.</p>
<p>One note before beginning:</p>
<ul>
<li>In regards to programming style, most Scala programmers indent their code with two spaces, but we use four spaces because we think it makes the code easier to read, especially in a book format.</li>
</ul>
<p>To begin reading, click the “next” link, or select the <em>Prelude: A Taste of Scala</em> lesson in the table of contents.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: Prelude꞉ A Taste of Scala
description: This page shares a Taste Of Scala example, quickly covering Scala's main features.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 2
outof: 54
previous-page: introduction
next-page: preliminaries</h2>
<p>Our hope in this book is to demonstrate that <a href="http://scala-lang.org">Scala</a> is a beautiful, modern, expressive programming language. To help demonstrate that, in this first chapter we’ll jump right in and provide a whirlwind tour of Scala’s main features. After this tour, the book begins with a more traditional “Getting Started” chapter.</p>
<blockquote>
<p>In this book we assume that you’ve used a language like Java before, and are ready to see a series of Scala examples to get a feel for what the language looks like. Although it’s not 100% necessary, it will also help if you’ve already <a href="https://www.scala-lang.org/download">downloaded and installed Scala</a> so you can test the examples as you go along. You can also test these examples online with <a href="https://scalafiddle.io">ScalaFiddle.io</a>.</p>
</blockquote>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Before we jump into the examples, here are a few important things to know about Scala:</p>
<ul>
<li>It’s a high-level language</li>
<li>It’s statically typed</li>
<li>Its syntax is concise but still readable — we call it <em>expressive</em></li>
<li>It supports the object-oriented programming (OOP) paradigm</li>
<li>It supports the functional programming (FP) paradigm</li>
<li>It has a sophisticated type inference system</li>
<li>Scala code results in <em>.class</em> files that run on the Java Virtual Machine (JVM)</li>
<li>It’s easy to use Java libraries in Scala</li>
</ul>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, world</a></h2>
<p>Ever since the book, <em>C Programming Language</em>, it’s been a tradition to begin programming books with a “Hello, world” example, and not to disappoint, this is one way to write that example in Scala:</p>
<pre><code class="language-scala">object Hello extends App {
    println(&quot;Hello, world&quot;)
}
</code></pre>
<p>After you save that code to a file named <em>Hello.scala</em>, you can compile it with <code>scalac</code>:</p>
<pre><code class="language-sh">$ scalac Hello.scala
</code></pre>
<p>If you’re coming to Scala from Java, <code>scalac</code> is just like <code>javac</code>, and that command creates two files:</p>
<ul>
<li><em>Hello$.class</em></li>
<li><em>Hello.class</em></li>
</ul>
<p>These are the same “.class” bytecode files you create with <code>javac</code>, and they’re ready to run in the JVM. You run the <code>Hello</code> application with the <code>scala</code> command:</p>
<pre><code class="language-sh">$ scala Hello
</code></pre>
<p>We share more “Hello, world” examples in the lessons that follow, so we’ll leave that introduction as-is for now.</p>
<h2 id="the-scala-repl"><a class="header" href="#the-scala-repl">The Scala REPL</a></h2>
<p>The Scala REPL (“Read-Evaluate-Print-Loop”) is a command-line interpreter that you use as a “playground” area to test your Scala code. We introduce it early here so you can use it with the code examples that follow.</p>
<p>To start a REPL session, just type <code>scala</code> at your operating system command line, and you’ll see something like this:</p>
<pre><code class="language-scala">$ scala
Welcome to Scala 2.13.0 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_131).
Type in expressions for evaluation. Or try :help.

scala&gt; _
</code></pre>
<p>Because the REPL is a command-line interpreter, it just sits there waiting for you to type something. Inside the REPL you type Scala expressions to see how they work:</p>
<pre><code class="language-scala">scala&gt; val x = 1
x: Int = 1

scala&gt; val y = x + 1
y: Int = 2
</code></pre>
<p>As those examples show, after you type your expressions in the REPL, it shows the result of each expression on the line following the prompt.</p>
<h2 id="two-types-of-variables"><a class="header" href="#two-types-of-variables">Two types of variables</a></h2>
<p>Scala has two types of variables:</p>
<ul>
<li><code>val</code> is an immutable variable — like <code>final</code> in Java — and should be preferred</li>
<li><code>var</code> creates a mutable variable, and should only be used when there is a specific reason to use it</li>
<li>Examples:</li>
</ul>
<pre><code class="language-scala">val x = 1   //immutable
var y = 0   //mutable
</code></pre>
<h2 id="declaring-variable-types"><a class="header" href="#declaring-variable-types">Declaring variable types</a></h2>
<p>In Scala, you typically create variables without declaring their type:</p>
<pre><code class="language-scala">val x = 1
val s = &quot;a string&quot;
val p = new Person(&quot;Regina&quot;)
</code></pre>
<p>When you do this, Scala can usually infer the data type for you, as shown in these REPL examples:</p>
<pre><code class="language-scala">scala&gt; val x = 1
val x: Int = 1

scala&gt; val s = &quot;a string&quot;
val s: String = a string
</code></pre>
<p>This feature is known as <em>type inference</em>, and it’s a great way to help keep your code concise. You can also <em>explicitly</em> declare a variable’s type, but that’s not usually necessary:</p>
<pre><code class="language-scala">val x: Int = 1
val s: String = &quot;a string&quot;
val p: Person = new Person(&quot;Regina&quot;)
</code></pre>
<p>As you can see, that code looks unnecessarily verbose.</p>
<h2 id="control-structures"><a class="header" href="#control-structures">Control structures</a></h2>
<p>Here’s a quick tour of Scala’s control structures.</p>
<h3 id="ifelse"><a class="header" href="#ifelse">if/else</a></h3>
<p>Scala’s if/else control structure is similar to other languages:</p>
<pre><code class="language-scala">if (test1) {
    doA()
} else if (test2) {
    doB()
} else if (test3) {
    doC()
} else {
    doD()
}
</code></pre>
<p>However, unlike Java and many other languages, the if/else construct returns a value, so, among other things, you can use it as a ternary operator:</p>
<pre><code class="language-scala">val x = if (a &lt; b) a else b
</code></pre>
<h3 id="match-expressions"><a class="header" href="#match-expressions">match expressions</a></h3>
<p>Scala has a <code>match</code> expression, which in its most basic use is like a Java <code>switch</code> statement:</p>
<pre><code class="language-scala">val result = i match {
    case 1 =&gt; &quot;one&quot;
    case 2 =&gt; &quot;two&quot;
    case _ =&gt; &quot;not 1 or 2&quot;
}
</code></pre>
<p>The <code>match</code> expression isn’t limited to just integers, it can be used with any data type, including booleans:</p>
<pre><code class="language-scala">val booleanAsString = bool match {
    case true =&gt; &quot;true&quot;
    case false =&gt; &quot;false&quot;
}
</code></pre>
<p>Here’s an example of <code>match</code> being used as the body of a method, and matching against many different types:</p>
<pre><code class="language-scala">def getClassAsString(x: Any):String = x match {
    case s: String =&gt; s + &quot; is a String&quot;
    case i: Int =&gt; &quot;Int&quot;
    case f: Float =&gt; &quot;Float&quot;
    case l: List[_] =&gt; &quot;List&quot;
    case p: Person =&gt; &quot;Person&quot;
    case _ =&gt; &quot;Unknown&quot;
}
</code></pre>
<p>Powerful match expressions are a big feature of Scala, and we share more examples of it later in this book.</p>
<h3 id="trycatch"><a class="header" href="#trycatch">try/catch</a></h3>
<p>Scala’s try/catch control structure lets you catch exceptions. It’s similar to Java, but its syntax is consistent with match expressions:</p>
<pre><code class="language-scala">try {
    writeToFile(text)
} catch {
    case fnfe: FileNotFoundException =&gt; println(fnfe)
    case ioe: IOException =&gt; println(ioe)
}
</code></pre>
<h3 id="for-loops-and-expressions"><a class="header" href="#for-loops-and-expressions">for loops and expressions</a></h3>
<p>Scala <code>for</code> loops — which we generally write in this book as <em>for-loops</em> — look like this:</p>
<pre><code class="language-scala">for (arg &lt;- args) println(arg)

// &quot;x to y&quot; syntax
for (i &lt;- 0 to 5) println(i)

// &quot;x to y by&quot; syntax
for (i &lt;- 0 to 10 by 2) println(i)
</code></pre>
<p>You can also add the <code>yield</code> keyword to for-loops to create <em>for-expressions</em> that yield a result. Here’s a for-expression that doubles each value in the sequence 1 to 5:</p>
<pre><code class="language-scala">val x = for (i &lt;- 1 to 5) yield i * 2
</code></pre>
<p>Here’s another for-expression that iterates over a list of strings:</p>
<pre><code class="language-scala">val fruits = List(&quot;apple&quot;, &quot;banana&quot;, &quot;lime&quot;, &quot;orange&quot;)

val fruitLengths = for {
    f &lt;- fruits
    if f.length &gt; 4
} yield f.length
</code></pre>
<p>Because Scala code generally just makes sense, we’ll imagine that you can guess how this code works, even if you’ve never seen a for-expression or Scala list until now.</p>
<h3 id="while-and-dowhile"><a class="header" href="#while-and-dowhile">while and do/while</a></h3>
<p>Scala also has <code>while</code> and <code>do</code>/<code>while</code> loops. Here’s their general syntax:</p>
<pre><code class="language-scala">// while loop
while(condition) {
    statement(a)
    statement(b)
}

// do-while
do {
   statement(a)
   statement(b)
} 
while(condition)
</code></pre>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<p>Here’s an example of a Scala class:</p>
<pre><code class="language-scala">class Person(var firstName: String, var lastName: String) {
    def printFullName() = println(s&quot;$firstName $lastName&quot;)
}
</code></pre>
<p>This is how you use that class:</p>
<pre><code class="language-scala">val p = new Person(&quot;Julia&quot;, &quot;Kern&quot;)
println(p.firstName)
p.lastName = &quot;Manes&quot;
p.printFullName()
</code></pre>
<p>Notice that there’s no need to create “get” and “set” methods to access the fields in the class.</p>
<p>As a more complicated example, here’s a <code>Pizza</code> class that you’ll see later in the book:</p>
<pre><code class="language-scala">class Pizza (
    var crustSize: CrustSize,
    var crustType: CrustType,
    val toppings: ArrayBuffer[Topping]
) {
    def addTopping(t: Topping): Unit = toppings += t
    def removeTopping(t: Topping): Unit = toppings -= t
    def removeAllToppings(): Unit = toppings.clear()
}
</code></pre>
<p>In that code, an <code>ArrayBuffer</code> is like Java’s <code>ArrayList</code>. The <code>CrustSize</code>, <code>CrustType</code>, and <code>Topping</code> classes aren’t shown, but you can probably understand how that code works without needing to see those classes.</p>
<h2 id="scala-methods"><a class="header" href="#scala-methods">Scala methods</a></h2>
<p>Just like other OOP languages, Scala classes have methods, and this is what the Scala method syntax looks like:</p>
<pre><code class="language-scala">def sum(a: Int, b: Int): Int = a + b
def concatenate(s1: String, s2: String): String = s1 + s2
</code></pre>
<p>You don’t have to declare a method’s return type, so it’s perfectly legal to write those two methods like this, if you prefer:</p>
<pre><code class="language-scala">def sum(a: Int, b: Int) = a + b
def concatenate(s1: String, s2: String) = s1 + s2
</code></pre>
<p>This is how you call those methods:</p>
<pre><code class="language-scala">val x = sum(1, 2)
val y = concatenate(&quot;foo&quot;, &quot;bar&quot;)
</code></pre>
<p>There are more things you can do with methods, such as providing default values for method parameters, but that’s a good start for now.</p>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>Traits in Scala are a lot of fun, and they also let you break your code down into small, modular units. To demonstrate traits, here’s an example from later in the book. Given these three traits:</p>
<pre><code class="language-scala">trait Speaker {
    def speak(): String  // has no body, so it’s abstract
}

trait TailWagger {
    def startTail(): Unit = println(&quot;tail is wagging&quot;)
    def stopTail(): Unit = println(&quot;tail is stopped&quot;)
}

trait Runner {
    def startRunning(): Unit = println(&quot;I’m running&quot;)
    def stopRunning(): Unit = println(&quot;Stopped running&quot;)
}
</code></pre>
<p>You can create a <code>Dog</code> class that extends all of those traits while providing behavior for the <code>speak</code> method:</p>
<pre><code class="language-scala">class Dog(name: String) extends Speaker with TailWagger with Runner {
    def speak(): String = &quot;Woof!&quot;
}
</code></pre>
<p>Similarly, here’s a <code>Cat</code> class that shows how to override multiple trait methods:</p>
<pre><code class="language-scala">class Cat extends Speaker with TailWagger with Runner {
    def speak(): String = &quot;Meow&quot;
    override def startRunning(): Unit = println(&quot;Yeah ... I don’t run&quot;)
    override def stopRunning(): Unit = println(&quot;No need to stop&quot;)
}
</code></pre>
<p>If that code makes sense — great, you’re comfortable with traits! If not, don’t worry, we explain it in detail later in the book.</p>
<h2 id="collections-classes"><a class="header" href="#collections-classes">Collections classes</a></h2>
<p>If you’re coming to Scala from Java and you’re ready to really jump in and learn Scala, it’s possible to use the Java collections classes in Scala, and some people do so for several weeks or months while getting comfortable with Scala. But it’s highly recommended that you learn the basic Scala collections classes — <code>List</code>, <code>ListBuffer</code>, <code>Vector</code>, <code>ArrayBuffer</code>, <code>Map</code>, and <code>Set</code> — as soon as possible. A great benefit of the Scala collections classes is that they offer many powerful methods that you’ll want to start using as soon as possible to simplify your code.</p>
<h3 id="populating-lists"><a class="header" href="#populating-lists">Populating lists</a></h3>
<p>There are times when it’s helpful to create sample lists that are populated with data, and Scala offers many ways to populate lists. Here are just a few:</p>
<pre><code class="language-scala">val nums = List.range(0, 10)
val nums = (1 to 10 by 2).toList
val letters = ('a' to 'f').toList
val letters = ('a' to 'f' by 2).toList
</code></pre>
<h3 id="sequence-methods"><a class="header" href="#sequence-methods">Sequence methods</a></h3>
<p>While there are many sequential collections classes you can use — <code>Array</code>, <code>ArrayBuffer</code>, <code>Vector</code>, <code>List</code>, and more — let’s look at some examples of what you can do with the <code>List</code> class. Given these two lists:</p>
<pre><code class="language-scala">val nums = (1 to 10).toList
val names = List(&quot;joel&quot;, &quot;ed&quot;, &quot;chris&quot;, &quot;maurice&quot;)
</code></pre>
<p>This is the <code>foreach</code> method:</p>
<pre><code class="language-scala">scala&gt; names.foreach(println)
joel
ed
chris
maurice
</code></pre>
<p>Here’s the <code>filter</code> method, followed by <code>foreach</code>:</p>
<pre><code class="language-scala">scala&gt; nums.filter(_ &lt; 4).foreach(println)
1
2
3
</code></pre>
<p>Here are some examples of the <code>map</code> method:</p>
<pre><code class="language-scala">scala&gt; val doubles = nums.map(_ * 2)
doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)

scala&gt; val capNames = names.map(_.capitalize)
capNames: List[String] = List(Joel, Ed, Chris, Maurice)

scala&gt; val lessThanFive = nums.map(_ &lt; 5)
lessThanFive: List[Boolean] = List(true, true, true, true, false, false, false, false, false, false)
</code></pre>
<p>Even without any explanation you can see how <code>map</code> works: It applies an algorithm you supply to every element in the collection, returning a new, transformed value for each element.</p>
<p>If you’re ready to see one of the most powerful collections methods, here’s <code>foldLeft</code>:</p>
<pre><code class="language-scala">scala&gt; nums.foldLeft(0)(_ + _)
res0: Int = 55

scala&gt; nums.foldLeft(1)(_ * _)
res1: Int = 3628800
</code></pre>
<p>Once you know that the first parameter to <code>foldLeft</code> is a <em>seed</em> value, you can guess that the first example yields the <em>sum</em> of the numbers in <code>nums</code>, and the second example returns the <em>product</em> of all those numbers.</p>
<p>There are many (many!) more methods available to Scala collections classes, and many of them will be demonstrated in the collections lessons that follow, but hopefully this gives you an idea of their power.</p>
<blockquote>
<p>For more details, jump to <a href="%7B%7Bsite.baseurl%7D%7D/overviews/scala-book/collections-101.html">the Scala Book collections lessons</a>, or see <a href="%7B%7Bsite.baseurl%7D%7D/overviews/collections-2.13/overview.html">the Mutable and Immutable collections overview</a> for more details and examples.</p>
</blockquote>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Tuples let you put a heterogenous collection of elements in a little container. A tuple can contain between two and 22 values, and all of the values can have different types. For example, this is a tuple that holds three different types, an <code>Int</code>, a <code>Double</code>, and a <code>String</code>:</p>
<pre><code class="language-scala">(11, 11.0, &quot;Eleven&quot;)
</code></pre>
<p>This is known as a <code>Tuple3</code>, because it contains three elements.</p>
<p>Tuples are convenient in many places, such as where you might use an ad-hoc class in other languages. For instance, you can return a tuple from a method instead of returning a class:</p>
<pre><code class="language-scala">def getAaplInfo(): (String, BigDecimal, Long) = {
    // get the stock symbol, price, and volume
    (&quot;AAPL&quot;, BigDecimal(123.45), 101202303L)
}
</code></pre>
<p>Then you can assign the result of the method to a variable:</p>
<pre><code class="language-scala">val t = getAaplInfo()
</code></pre>
<p>Once you have a tuple variable, you can access its values by number, preceded by an underscore:</p>
<pre><code class="language-scala">t._1
t._2
t._3
</code></pre>
<p>The REPL demonstrates the results of accessing those fields:</p>
<pre><code class="language-scala">scala&gt; t._1
res0: String = AAPL

scala&gt; t._2
res1: scala.math.BigDecimal = 123.45

scala&gt; t._3
res2: Long = 101202303
</code></pre>
<p>The values of a tuple can also be extracted using pattern matching. In this next example, the fields inside the tuple are assigned to the variables <code>symbol</code>, <code>price</code>, and <code>volume</code>:</p>
<pre><code class="language-scala">val (symbol, price, volume) = getAaplInfo()
</code></pre>
<p>Once again, the REPL shows the result:</p>
<pre><code class="language-scala">scala&gt; val (symbol, price, volume) = getAaplInfo()
symbol: String = AAPL
price: scala.math.BigDecimal = 123.45
volume: Long = 101202303
</code></pre>
<p>Tuples are nice for those times when you want to quickly (and temporarily) group some things together.
If you notice that you are using the same tuples multiple times, it could be useful to declare a dedicated case class, such as:</p>
<pre><code class="language-scala">case class StockInfo(symbol: String, price: BigDecimal, volume: Long)
</code></pre>
<h2 id="what-we-havent-shown"><a class="header" href="#what-we-havent-shown">What we haven’t shown</a></h2>
<p>While that was whirlwind introduction to Scala in about ten printed pages, there are many things we haven’t shown yet, including:</p>
<ul>
<li>Strings and built-in numeric types</li>
<li>Packaging and imports</li>
<li>How to use Java collections classes in Scala</li>
<li>How to use Java libraries in Scala</li>
<li>How to build Scala projects</li>
<li>How to perform unit testing in Scala</li>
<li>How to write Scala shell scripts</li>
<li>Maps, Sets, and other collections classes</li>
<li>Object-oriented programming</li>
<li>Functional programming</li>
<li>Concurrency with Futures</li>
<li>More ...</li>
</ul>
<p>If you like what you’ve seen so far, we hope you’ll like the rest of the book.</p>
<h2 id="a-bit-of-background"><a class="header" href="#a-bit-of-background">A bit of background</a></h2>
<p>Scala was created by <a href="https://en.wikipedia.org/wiki/Martin_Odersky">Martin Odersky</a>, who studied under <a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>, who created Pascal and several other languages. Mr. Odersky is one of the co-designers of Generic Java, and is also known as the “father” of the <code>javac</code> compiler.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: Preliminaries
description: A few things to know about getting started with Scala.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 3
outof: 54
previous-page: prelude-taste-of-scala
next-page: scala-features</h2>
<p>In this book we assume that you’re familiar with another language like Java, so we don’t spend much time on programming basics. That is, we assume that you’ve seen things like for-loops, classes, and methods before, so we generally only write, “This is how you create a class in Scala,” that sort of thing.</p>
<p>That being said, there are a few good things to know before you read this book.</p>
<h2 id="installing-scala"><a class="header" href="#installing-scala">Installing Scala</a></h2>
<p>First, to run the examples in this book you’ll need to install Scala on your computer. See our general <a href="%7B%7Bsite.baseurl%7D%7D/getting-started/index.html">Getting Started</a> page for details on how to use Scala (a) in an IDE and (b) from the command line.</p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>One good thing to know up front is that comments in Scala are just like comments in Java (and many other languages):</p>
<pre><code class="language-scala">// a single line comment

/*
 * a multiline comment
 */

/**
 * also a multiline comment
 */
</code></pre>
<h2 id="ides"><a class="header" href="#ides">IDEs</a></h2>
<p>The three main IDEs (integrated development environments) for Scala are:</p>
<ul>
<li><a href="https://www.jetbrains.com/idea/download">IntelliJ IDEA</a></li>
<li><a href="https://code.visualstudio.com">Visual Studio Code</a></li>
<li><a href="http://scala-ide.org">Scala IDE for Eclipse</a></li>
</ul>
<h2 id="naming-conventions"><a class="header" href="#naming-conventions">Naming conventions</a></h2>
<p>Another good thing to know is that Scala naming conventions follow the same “camel case” style as Java:</p>
<ul>
<li>Class names: <code>Person</code>, <code>StoreEmployee</code></li>
<li>Variable names: <code>name</code>, <code>firstName</code></li>
<li>Method names: <code>convertToInt</code>, <code>toUpper</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Scala Features
description: TODO
partof: scala_book
overview-name: Scala Book
discourse: true
num: 4
outof: 54
previous-page: preliminaries
next-page: hello-world-1</h2>
<p>The name <em>Scala</em> comes from the word <em>scalable</em>, and true to that name, it’s used to power the busiest websites in the world, including Twitter, Netflix, Tumblr, LinkedIn, Foursquare, and many more.</p>
<p>Here are a few more nuggets about Scala:</p>
<ul>
<li>It’s a modern programming language created by <a href="https://twitter.com/odersky?lang=en">Martin Odersky</a> (the father of <code>javac</code>), and influenced by Java, Ruby, Smalltalk, ML, Haskell, Erlang, and others.</li>
<li>It’s a high-level language.</li>
<li>It’s statically typed.</li>
<li>It has a sophisticated type inference system.</li>
<li>Its syntax is concise but still readable — we call it <em>expressive</em>.</li>
<li>It’s a pure object-oriented programming (OOP) language. Every variable is an object, and every “operator” is a method.</li>
<li>It’s also a functional programming (FP) language, so functions are also variables, and you can pass them into other functions. You can write your code using OOP, FP, or combine them in a hybrid style.</li>
<li>Scala source code compiles to “.class” files that run on the JVM.</li>
<li>Scala also works extremely well with the thousands of Java libraries that have been developed over the years.</li>
<li>A great thing about Scala is that you can be productive with it on Day 1, but it’s also a deep language, so as you go along you’ll keep learning, and finding newer, better ways to write code. Some people say that Scala will change the way you think about programming (and that’s a good thing).</li>
<li>A great Scala benefit is that it lets you write concise, readable code. The time a programmer spends reading code compared to the time spent writing code is said to be at least a 10:1 ratio, so writing code that’s <em>concise and readable</em> is a big deal. Because Scala has these attributes, programmers say that it’s <em>expressive</em>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Hello, World
description: This page shares a Scala 'Hello, world' example.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 5
outof: 54
previous-page: scala-features
next-page: hello-world-2</h2>
<p>Since the release of the book, <em>C Programming Language</em>, most programming books have begun with a simple “Hello, world” example, and in keeping with tradition, here’s the source code for a Scala “Hello, world” example:</p>
<pre><code class="language-scala">object Hello {
    def main(args: Array[String]) = {
        println(&quot;Hello, world&quot;)
    }
}
</code></pre>
<p>Using a text editor, save that source code in a file named <em>Hello.scala</em>. After saving it, run this <code>scalac</code> command at your command line prompt to compile it:</p>
<pre><code class="language-sh">$ scalac Hello.scala
</code></pre>
<p><code>scalac</code> is just like <code>javac</code>, and that command creates two new files:</p>
<ul>
<li>Hello$.class</li>
<li>Hello.class</li>
</ul>
<p>These are the same types of “.class” bytecode files you create with <code>javac</code>, and they’re ready to work with the JVM.</p>
<p>Now you can run the <code>Hello</code> application with the <code>scala</code> command:</p>
<pre><code class="language-sh">$ scala Hello
</code></pre>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>Here’s the original source code again:</p>
<pre><code class="language-scala">object Hello {
    def main(args: Array[String]) = {
        println(&quot;Hello, world&quot;)
    }
}
</code></pre>
<p>Here’s a short description of that code:</p>
<ul>
<li>It defines a method named <code>main</code> inside a Scala <code>object</code> named <code>Hello</code></li>
<li>An <code>object</code> is similar to a <code>class</code>, but you specifically use it when you want a single instance of that class
<ul>
<li>If you’re coming to Scala from Java, this means that <code>main</code> is just like a <code>static</code> method (We write more on this later)</li>
</ul>
</li>
<li><code>main</code> takes an input parameter named <code>args</code> that is a string array</li>
<li><code>Array</code> is a class that wraps the Java <code>array</code> primitive</li>
</ul>
<p>That Scala code is pretty much the same as this Java code:</p>
<pre><code class="language-java">public class Hello {
    public static void main(String[] args) {
        System.out.println(&quot;Hello, world&quot;);
    }
}
</code></pre>
<h2 id="going-deeper-scala-creates-class-files"><a class="header" href="#going-deeper-scala-creates-class-files">Going deeper: Scala creates <em>.class</em> files</a></h2>
<p>As we mentioned, when you run the <code>scalac</code> command it creates <em>.class</em> JVM bytecode files. You can see this for yourself. As an example, run this <code>javap</code> command on the <em>Hello.class</em> file:</p>
<pre><code>$ javap Hello.class
Compiled from &quot;Hello.scala&quot;
public final class Hello {
  public static void main(java.lang.String[]);
}
</code></pre>
<p>As that output shows, the <code>javap</code> command reads that <em>.class</em> file just as if it was created from Java source code. Scala code runs on the JVM and can use existing Java libraries — and both are terrific benefits for Scala programmers.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Hello, World - Version 2
description: This is a second Scala 'Hello, World' example.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 6
outof: 54
previous-page: hello-world-1
next-page: scala-repl</h2>
<p>While that first “Hello, World” example works just fine, Scala provides a way to write applications more conveniently. Rather than including a <code>main</code> method, your <code>object</code> can just extend the <code>App</code> trait, like this:</p>
<pre><code class="language-scala">object Hello2 extends App {
    println(&quot;Hello, world&quot;)
}
</code></pre>
<p>If you save that code to <em>Hello.scala</em>, compile it with <code>scalac</code> and run it with <code>scala</code>, you’ll see the same result as the previous lesson.</p>
<p>What happens here is that the <code>App</code> trait has its own <code>main</code> method, so you don’t need to write one. We’ll show later on how you can access command-line arguments with this approach, but the short story is that it’s easy: they’re made available to you in a string array named <code>args</code>.</p>
<blockquote>
<p>We haven’t mentioned it yet, but a Scala <code>trait</code> is similar to an abstract class in Java. (More accurately, it’s a combination of an abstract class and an interface — more on this later!)</p>
</blockquote>
<h2 id="extra-credit"><a class="header" href="#extra-credit">Extra credit</a></h2>
<p>If you want to see how command-line arguments work when your object extends the <code>App</code> trait, save this source code in a file named <em>HelloYou.scala</em>:</p>
<pre><code class="language-scala">object HelloYou extends App {
    if (args.size == 0)
        println(&quot;Hello, you&quot;)
    else
        println(&quot;Hello, &quot; + args(0))
}
</code></pre>
<p>Then compile it with <code>scalac</code>:</p>
<pre><code class="language-sh">scalac HelloYou.scala
</code></pre>
<p>Then run it with and without command-line arguments. Here’s an example:</p>
<pre><code class="language-sh">$ scala HelloYou
Hello, you

$ scala HelloYou Al
Hello, Al
</code></pre>
<p>This shows:</p>
<ul>
<li>Command-line arguments are automatically made available to you in a variable named <code>args</code>.</li>
<li>You determine the number of elements in <code>args</code> with <code>args.size</code> (or <code>args.length</code>, if you prefer).</li>
<li><code>args</code> is an <code>Array</code>, and you access <code>Array</code> elements as <code>args(0)</code>, <code>args(1)</code>, etc. Because <code>args</code> is an object, you access the array elements with parentheses (not <code>[]</code> or any other special syntax).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: The Scala REPL
description: This page shares an introduction to the Scala REPL.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 7
outof: 54
previous-page: hello-world-2
next-page: two-types-variables</h2>
<p>The Scala REPL (“Read-Evaluate-Print-Loop”) is a command-line interpreter that you use as a “playground” area to test your Scala code. To start a REPL session, just type <code>scala</code> at your operating system command line, and you’ll see this:</p>
<pre><code class="language-scala">$ scala
Welcome to Scala 2.13.0 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_131).
Type in expressions for evaluation. Or try :help.

scala&gt; _
</code></pre>
<p>Because the REPL is a command-line interpreter, it just sits there waiting for you to type something. Once you’re in the REPL, you can type Scala expressions to see how they work:</p>
<pre><code class="language-scala">scala&gt; val x = 1
x: Int = 1

scala&gt; val y = x + 1
y: Int = 2
</code></pre>
<p>As those examples show, just type your expressions inside the REPL, and it shows the result of each expression on the line following the prompt.</p>
<h2 id="variables-created-as-needed"><a class="header" href="#variables-created-as-needed">Variables created as needed</a></h2>
<p>Note that if you don’t assign the result of your expression to a variable, the REPL automatically creates variables that start with the name <code>res</code>. The first variable is <code>res0</code>, the second one is <code>res1</code>, etc.:</p>
<pre><code class="language-scala">scala&gt; 2 + 2
res0: Int = 4

scala&gt; 3 / 3
res1: Int = 1
</code></pre>
<p>These are actual variable names that are dynamically created, and you can use them in your expressions:</p>
<pre><code class="language-scala">scala&gt; val z = res0 + res1
z: Int = 5
</code></pre>
<p>You’re going to use the REPL a lot in this book, so go ahead and start experimenting with it. Here are a few expressions you can try to see how it all works:</p>
<pre><code class="language-scala">val name = &quot;John Doe&quot;
&quot;hello&quot;.head
&quot;hello&quot;.tail
&quot;hello, world&quot;.take(5)
println(&quot;hi&quot;)
1 + 2 * 3
(1 + 2) * 3
if (2 &gt; 1) println(&quot;greater&quot;) else println(&quot;lesser&quot;)
</code></pre>
<p>In addition to the REPL there are a couple of other, similar tools you can use:</p>
<ul>
<li><a href="https://scastie.scala-lang.org">Scastie</a> is “an interactive playground for Scala” with several nice features, including being able to control build settings and share code snippets</li>
<li>IntelliJ IDEA has a Worksheet plugin that lets you do the same things inside your IDE</li>
<li>The Scala IDE for Eclipse also has a Worksheet plugin</li>
<li><a href="https://scalafiddle.io">scalafiddle.io</a> lets you run similar experiments in a web browser</li>
</ul>
<p>For more information on the Scala REPL, see the <a href="%7B%7Bsite.baseurl%7D%7D/overviews/repl/overview.html">Scala REPL overview</a></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Two Types of Variables
description: Scala has two types of variables, val and var.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 8
outof: 54
previous-page: scala-repl
next-page: type-is-optional</h2>
<p>In Java you declare new variables like this:</p>
<pre><code class="language-java">String s = &quot;hello&quot;;
int i = 42;
Person p = new Person(&quot;Joel Fleischman&quot;);
</code></pre>
<p>Each variable declaration is preceded by its type.</p>
<p>By contrast, Scala has two types of variables:</p>
<ul>
<li><code>val</code> creates an <em>immutable</em> variable (like <code>final</code> in Java)</li>
<li><code>var</code> creates a <em>mutable</em> variable</li>
</ul>
<p>This is what variable declaration looks like in Scala:</p>
<pre><code class="language-scala">val s = &quot;hello&quot;   // immutable
var i = 42        // mutable

val p = new Person(&quot;Joel Fleischman&quot;)
</code></pre>
<p>Those examples show that the Scala compiler is usually smart enough to infer the variable’s data type from the code on the right side of the <code>=</code> sign. We say that the variable’s type is <em>inferred</em> by the compiler. You can also <em>explicitly</em> declare the variable type if you prefer:</p>
<pre><code class="language-scala">val s: String = &quot;hello&quot;
var i: Int = 42
</code></pre>
<p>In most cases the compiler doesn’t need to see those explicit types, but you can add them if you think it makes your code easier to read.</p>
<blockquote>
<p>As a practical matter it can help to explicitly show the type when you’re working with methods in third-party libraries, especially if you don’t use the library often, or if their method names don’t make the type clear.</p>
</blockquote>
<h2 id="the-difference-between-val-and-var"><a class="header" href="#the-difference-between-val-and-var">The difference between <code>val</code> and <code>var</code></a></h2>
<p>The difference between <code>val</code> and <code>var</code> is that <code>val</code> makes a variable <em>immutable</em> — like <code>final</code> in Java — and <code>var</code> makes a variable <em>mutable</em>. Because <code>val</code> fields can’t vary, some people refer to them as <em>values</em> rather than variables.</p>
<p>The REPL shows what happens when you try to reassign a <code>val</code> field:</p>
<pre><code class="language-scala">scala&gt; val a = 'a'
a: Char = a

scala&gt; a = 'b'
&lt;console&gt;:12: error: reassignment to val
       a = 'b'
         ^
</code></pre>
<p>That fails with a “reassignment to val” error, as expected. Conversely, you can reassign a <code>var</code>:</p>
<pre><code class="language-scala">scala&gt; var a = 'a'
a: Char = a

scala&gt; a = 'b'
a: Char = b
</code></pre>
<p>In Scala the general rule is that you should always use a <code>val</code> field unless there’s a good reason not to. This simple rule (a) makes your code more like algebra and (b) helps get you started down the path to functional programming, where <em>all</em> fields are immutable.</p>
<h2 id="hello-world-with-a-val-field"><a class="header" href="#hello-world-with-a-val-field">“Hello, world” with a <code>val</code> field</a></h2>
<p>Here’s what a “Hello, world” app looks like with a <code>val</code> field:</p>
<pre><code class="language-scala">object Hello3 extends App {
    val hello = &quot;Hello, world&quot;
    println(hello)
}
</code></pre>
<p>As before:</p>
<ul>
<li>Save that code in a file named <em>Hello3.scala</em></li>
<li>Compile it with <code>scalac Hello3.scala</code></li>
<li>Run it with <code>scala Hello3</code></li>
</ul>
<h2 id="a-note-about-val-fields-in-the-repl"><a class="header" href="#a-note-about-val-fields-in-the-repl">A note about <code>val</code> fields in the REPL</a></h2>
<p>The REPL isn’t 100% the same as working with source code in an IDE, so there are a few things you can do in the REPL that you can’t do when working on real-world code in a project. One example of this is that you can redefine a <code>val</code> field in the REPL, like this:</p>
<pre><code class="language-scala">scala&gt; val age = 18
age: Int = 18

scala&gt; val age = 19
age: Int = 19
</code></pre>
<p><code>val</code> fields can’t be redefined like that in the real world, but they can be redefined in the REPL playground.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: The Type is Optional
description: A note about explicit and implicit data type declarations in Scala.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 9
outof: 54
previous-page: two-types-variables
next-page: built-in-types</h2>
<p>As we showed in the previous lesson, when you create a new variable in Scala you can <em>explicitly</em> declare its type, like this:</p>
<pre><code class="language-scala">val count: Int = 1
val name: String = &quot;Alvin&quot;
</code></pre>
<p>However, you can generally leave the type off and Scala can infer it for you:</p>
<pre><code class="language-scala">val count = 1
val name = &quot;Alvin&quot;
</code></pre>
<p>In most cases your code is easier to read when you leave the type off, so this inferred form is preferred.</p>
<h2 id="the-explicit-form-feels-verbose"><a class="header" href="#the-explicit-form-feels-verbose">The explicit form feels verbose</a></h2>
<p>For instance, in this example it’s obvious that the data type is <code>Person</code>, so there’s no need to declare the type on the left side of the expression:</p>
<pre><code class="language-scala">val p = new Person(&quot;Candy&quot;)
</code></pre>
<p>By contrast, when you put the type next to the variable name, the code feels unnecessarily verbose:</p>
<pre><code class="language-scala">val p: Person = new Person(&quot;Leo&quot;)
</code></pre>
<p>In summary:</p>
<pre><code class="language-scala">val p = new Person(&quot;Candy&quot;)           // preferred
val p: Person = new Person(&quot;Candy&quot;)   // unnecessarily verbose
</code></pre>
<h2 id="use-the-explicit-form-when-you-need-to-be-clear"><a class="header" href="#use-the-explicit-form-when-you-need-to-be-clear">Use the explicit form when you need to be clear</a></h2>
<p>One place where you’ll want to show the data type is when you want to be clear about what you’re creating. That is, if you don’t explicitly declare the data type, the compiler may make a wrong assumption about what you want to create. Some examples of this are when you want to create numbers with specific data types. We show this in the next lesson.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: A Few Built-In Types
description: A brief introduction to Scala's built-in types.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 10
outof: 54
previous-page: type-is-optional
next-page: two-notes-about-strings</h2>
<p>Scala comes with the standard numeric data types you’d expect. In Scala all of these data types are full-blown objects (not primitive data types).</p>
<p>These examples show how to declare variables of the basic numeric types:</p>
<pre><code class="language-scala">val b: Byte = 1
val x: Int = 1
val l: Long = 1
val s: Short = 1
val d: Double = 2.0
val f: Float = 3.0
</code></pre>
<p>In the first four examples, if you don’t explicitly specify a type, the number <code>1</code> will default to an <code>Int</code>, so if you want one of the other data types — <code>Byte</code>, <code>Long</code>, or <code>Short</code> — you need to explicitly declare those types, as shown. Numbers with a decimal (like 2.0) will default to a <code>Double</code>, so if you want a <code>Float</code> you need to declare a <code>Float</code>, as shown in the last example.</p>
<p>Because <code>Int</code> and <code>Double</code> are the default numeric types, you typically create them without explicitly declaring the data type:</p>
<pre><code class="language-scala">val i = 123   // defaults to Int
val x = 1.0   // defaults to Double
</code></pre>
<p>The REPL shows that those examples default to <code>Int</code> and <code>Double</code>:</p>
<pre><code class="language-scala">scala&gt; val i = 123
i: Int = 123

scala&gt; val x = 1.0
x: Double = 1.0
</code></pre>
<p>Those data types and their ranges are:</p>
<table><thead><tr><th>Data Type</th><th>Possible Values</th></tr></thead><tbody>
<tr><td>Boolean</td><td><code>true</code> or <code>false</code></td></tr>
<tr><td>Byte</td><td>8-bit signed two’s complement integer (-2^7 to 2^7-1, inclusive)<br/>-128 to 127</td></tr>
<tr><td>Short</td><td>16-bit signed two’s complement integer (-2^15 to 2^15-1, inclusive)<br/>-32,768 to 32,767</td></tr>
<tr><td>Int</td><td>32-bit two’s complement integer (-2^31 to 2^31-1, inclusive)<br/>-2,147,483,648 to 2,147,483,647</td></tr>
<tr><td>Long</td><td>64-bit two’s complement integer (-2^63 to 2^63-1, inclusive)<br/>(-2^63 to 2^63-1, inclusive)</td></tr>
<tr><td>Float</td><td>32-bit IEEE 754 single-precision float<br/>1.40129846432481707e-45 to 3.40282346638528860e+38</td></tr>
<tr><td>Double</td><td>64-bit IEEE 754 double-precision float<br/>4.94065645841246544e-324d to 1.79769313486231570e+308d</td></tr>
<tr><td>Char</td><td>16-bit unsigned Unicode character (0 to 2^16-1, inclusive)<br/>0 to 65,535</td></tr>
<tr><td>String</td><td>a sequence of <code>Char</code></td></tr>
</tbody></table>
<h2 id="bigint-and-bigdecimal"><a class="header" href="#bigint-and-bigdecimal">BigInt and BigDecimal</a></h2>
<p>For large numbers Scala also includes the types <code>BigInt</code> and <code>BigDecimal</code>:</p>
<pre><code class="language-scala">var b = BigInt(1234567890)
var b = BigDecimal(123456.789)
</code></pre>
<p>A great thing about <code>BigInt</code> and <code>BigDecimal</code> is that they support all the operators you’re used to using with numeric types:</p>
<pre><code class="language-scala">scala&gt; var b = BigInt(1234567890)
b: scala.math.BigInt = 1234567890

scala&gt; b + b
res0: scala.math.BigInt = 2469135780

scala&gt; b * b
res1: scala.math.BigInt = 1524157875019052100

scala&gt; b += 1

scala&gt; println(b)
1234567891
</code></pre>
<h2 id="string-and-char"><a class="header" href="#string-and-char">String and Char</a></h2>
<p>Scala also has <code>String</code> and <code>Char</code> data types, which you can generally declare with the implicit form:</p>
<pre><code class="language-scala">val name = &quot;Bill&quot;
val c = 'a'
</code></pre>
<p>Though once again, you can use the explicit form, if you prefer:</p>
<pre><code class="language-scala">val name: String = &quot;Bill&quot;
val c: Char = 'a'
</code></pre>
<p>As shown, enclose strings in double-quotes and a character in single-quotes.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Two Notes About Strings
description: This page shares two important notes about strings in Scala.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 11
outof: 54
previous-page: built-in-types
next-page: command-line-io</h2>
<p>Scala strings have a lot of nice features, but we want to take a moment to highlight two features that we’ll use in the rest of this book. The first feature is that Scala has a nice, Ruby-like way to merge multiple strings. Given these three variables:</p>
<pre><code class="language-scala">val firstName = &quot;John&quot;
val mi = 'C'
val lastName = &quot;Doe&quot;
</code></pre>
<p>you can append them together like this, if you want to:</p>
<pre><code class="language-scala">val name = firstName + &quot; &quot; + mi + &quot; &quot; + lastName
</code></pre>
<p>However, Scala provides this more convenient form:</p>
<pre><code class="language-scala">val name = s&quot;$firstName $mi $lastName&quot;
</code></pre>
<p>This form creates a very readable way to print strings that contain variables:</p>
<pre><code class="language-scala">println(s&quot;Name: $firstName $mi $lastName&quot;)
</code></pre>
<p>As shown, all you have to do is to precede the string with the letter <code>s</code>, and then put a <code>$</code> symbol before your variable names inside the string. This feature is known as <em>string interpolation</em>.</p>
<h3 id="more-features"><a class="header" href="#more-features">More features</a></h3>
<p>String interpolation in Scala provides many more features. For example, you can also enclose your variable names inside curly braces:</p>
<pre><code class="language-scala">println(s&quot;Name: ${firstName} ${mi} ${lastName}&quot;)
</code></pre>
<p>For some people that’s easier to read, but an even more important benefit is that you can put expressions inside the braces, as shown in this REPL example:</p>
<pre><code class="language-scala">scala&gt; println(s&quot;1+1 = ${1+1}&quot;)
1+1 = 2
</code></pre>
<p>A few other benefits of string interpolation are:</p>
<ul>
<li>You can precede strings with the letter <code>f</code>, which lets you use <em>printf</em> style formatting inside strings</li>
<li>The <code>raw</code> interpolator performs no escaping of literals (such as <code>\n</code>) within the string</li>
<li>You can create your own string interpolators</li>
</ul>
<p>See the <a href="%7B%7Bsite.baseurl%7D%7D/overviews/core/string-interpolation.html">string interpolation documentation</a> for more details.</p>
<h2 id="multiline-strings"><a class="header" href="#multiline-strings">Multiline strings</a></h2>
<p>A second great feature of Scala strings is that you can create multiline strings by including the string inside three double-quotes:</p>
<pre><code class="language-scala">val speech = &quot;&quot;&quot;Four score and
               seven years ago
               our fathers ...&quot;&quot;&quot;
</code></pre>
<p>That’s very helpful for when you need to work with multiline strings. One drawback of this basic approach is that lines after the first line are indented, as you can see in the REPL:</p>
<pre><code class="language-scala">scala&gt; val speech = &quot;&quot;&quot;Four score and
     |                seven years ago
     |                our fathers ...&quot;&quot;&quot;
speech: String =
Four score and
                   seven years ago
                   our fathers ...
</code></pre>
<p>A simple way to fix this problem is to put a <code>|</code> symbol in front of all lines after the first line, and call the <code>stripMargin</code> method after the string:</p>
<pre><code class="language-scala">val speech = &quot;&quot;&quot;Four score and
               |seven years ago
               |our fathers ...&quot;&quot;&quot;.stripMargin
</code></pre>
<p>The REPL shows that when you do this, all of the lines are left-justified:</p>
<pre><code class="language-scala">scala&gt; val speech = &quot;&quot;&quot;Four score and
     |                |seven years ago
     |                |our fathers ...&quot;&quot;&quot;.stripMargin
speech: String =
Four score and
seven years ago
our fathers ...
</code></pre>
<p>Because this is what you generally want, this is a common way to create multiline strings.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Command-Line I/O
description: An introduction to command-line I/O in Scala.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 12
outof: 54
previous-page: two-notes-about-strings
next-page: control-structures</h2>
<p>To get ready to show <code>for</code> loops, <code>if</code> expressions, and other Scala constructs, let’s take a look at how to handle command-line input and output with Scala.</p>
<h2 id="writing-output"><a class="header" href="#writing-output">Writing output</a></h2>
<p>As we’ve already shown, you write output to standard out (STDOUT) using <code>println</code>:</p>
<pre><code class="language-scala">println(&quot;Hello, world&quot;)
</code></pre>
<p>That function adds a newline character after your string, so if you don’t want that, just use <code>print</code> instead:</p>
<pre><code class="language-scala">print(&quot;Hello without newline&quot;)
</code></pre>
<p>When needed, you can also write output to standard error (STDERR) like this:</p>
<pre><code class="language-scala">System.err.println(&quot;yikes, an error happened&quot;)
</code></pre>
<blockquote>
<p>Because <code>println</code> is so commonly used, there’s no need to import it. The same is true of other commonly-used data types like <code>String</code>, <code>Int</code>, <code>Float</code>, etc.</p>
</blockquote>
<h2 id="reading-input"><a class="header" href="#reading-input">Reading input</a></h2>
<p>There are several ways to read command-line input, but the easiest way is to use the <code>readLine</code> method in the <em>scala.io.StdIn</em> package. To use it, you need to first import it, like this:</p>
<pre><code class="language-scala">import scala.io.StdIn.readLine
</code></pre>
<p>To demonstrate how this works, let’s create a little example. Put this source code in a file named <em>HelloInteractive.scala</em>:</p>
<pre><code class="language-scala">import scala.io.StdIn.readLine

object HelloInteractive extends App {

    print(&quot;Enter your first name: &quot;)
    val firstName = readLine()

    print(&quot;Enter your last name: &quot;)
    val lastName = readLine()

    println(s&quot;Your name is $firstName $lastName&quot;)

}
</code></pre>
<p>Then compile it with <code>scalac</code>:</p>
<pre><code class="language-sh">$ scalac HelloInteractive.scala
</code></pre>
<p>Then run it with <code>scala</code>:</p>
<pre><code class="language-sh">$ scala HelloInteractive
</code></pre>
<p>When you run the program and enter your first and last names at the prompts, the interaction looks like this:</p>
<pre><code class="language-sh">$ scala HelloInteractive
Enter your first name: Alvin
Enter your last name: Alexander
Your name is Alvin Alexander
</code></pre>
<h3 id="a-note-about-imports"><a class="header" href="#a-note-about-imports">A note about imports</a></h3>
<p>As you saw in this application, you bring classes and methods into scope in Scala just like you do with Java and other languages, with <code>import</code> statements:</p>
<pre><code class="language-scala">import scala.io.StdIn.readLine
</code></pre>
<p>That import statement brings the <code>readLine</code> method into the current scope so you can use it in the application.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: Control Structures
description: This page provides an introduction to Scala's control structures, including if/then/else, for loops, try/catch/finally, etc.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 13
outof: 54
previous-page: command-line-io
next-page: if-then-else-construct</h2>
<p>Scala has the basic control structures you’d expect to find in a programming language, including:</p>
<ul>
<li>if/then/else</li>
<li><code>for</code> loops</li>
<li>try/catch/finally</li>
</ul>
<p>It also has a few unique constructs, including:</p>
<ul>
<li><code>match</code> expressions</li>
<li><code>for</code> expressions</li>
</ul>
<p>We’ll demonstrate these in the following lessons.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: The if/then/else Construct
description: This page demonstrates Scala's if/then/else construct, including several examples you can try in the REPL.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 14
outof: 54
previous-page: control-structures
next-page: for-loops</h2>
<p>A basic Scala <code>if</code> statement looks like this:</p>
<pre><code class="language-scala">if (a == b) doSomething()
</code></pre>
<p>You can also write that statement like this:</p>
<pre><code class="language-scala">if (a == b) {
    doSomething()
}
</code></pre>
<p>The <code>if</code>/<code>else</code> construct looks like this:</p>
<pre><code class="language-scala">if (a == b) {
    doSomething()
} else {
    doSomethingElse()
}
</code></pre>
<p>The complete Scala if/else-if/else expression looks like this:</p>
<pre><code class="language-scala">if (test1) {
    doX()
} else if (test2) {
    doY()
} else {
    doZ()
}
</code></pre>
<h2 id="if-expressions-always-return-a-result"><a class="header" href="#if-expressions-always-return-a-result"><code>if</code> expressions always return a result</a></h2>
<p>A great thing about the Scala <code>if</code> construct is that it always returns a result. You can ignore the result as we did in the previous examples, but a more common approach — especially in functional programming — is to assign the result to a variable:</p>
<pre><code class="language-scala">val minValue = if (a &lt; b) a else b
</code></pre>
<p>This is cool for several reasons, including the fact that it means that Scala doesn’t require a special “ternary” operator.</p>
<h2 id="aside-expression-oriented-programming"><a class="header" href="#aside-expression-oriented-programming">Aside: Expression-oriented programming</a></h2>
<p>As a brief note about programming in general, when every expression you write returns a value, that style is referred to as <em>expression-oriented programming</em>, or EOP. This is an example of an <em>expression</em>:</p>
<pre><code class="language-scala">val minValue = if (a &lt; b) a else b
</code></pre>
<p>Conversely, lines of code that don’t return values are called <em>statements</em>, and they are used for their <em>side-effects</em>. For example, these lines of code don’t return values, so they are used for their side effects:</p>
<pre><code class="language-scala">if (a == b) doSomething()
println(&quot;Hello&quot;)
</code></pre>
<p>The first example runs the <code>doSomething</code> method as a side effect when <code>a</code> is equal to <code>b</code>. The second example is used for the side effect of writing a string to STDOUT. As you learn more about Scala you’ll find yourself writing more <em>expressions</em> and fewer <em>statements</em>. The differences between expressions and statements will also become more apparent.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: for Loops
description: This page provides an introduction to the Scala 'for' loop, including how to iterate over Scala collections.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 15
outof: 54
previous-page: if-then-else-construct
next-page: for-expressions</h2>
<p>In its most simple use, a Scala <code>for</code> loop can be used to iterate over the elements in a collection. For example, given a sequence of integers:</p>
<pre><code class="language-scala">val nums = Seq(1,2,3)
</code></pre>
<p>you can loop over them and print out their values like this:</p>
<pre><code class="language-scala">for (n &lt;- nums) println(n)
</code></pre>
<p>This is what the result looks like in the Scala REPL:</p>
<pre><code class="language-scala">scala&gt; val nums = Seq(1,2,3)
nums: Seq[Int] = List(1, 2, 3)

scala&gt; for (n &lt;- nums) println(n)
1
2
3
</code></pre>
<p>That example uses a sequence of integers, which has the data type <code>Seq[Int]</code>. Here’s a list of strings which has the data type <code>List[String]</code>:</p>
<pre><code class="language-scala">val people = List(
    &quot;Bill&quot;, 
    &quot;Candy&quot;, 
    &quot;Karen&quot;, 
    &quot;Leo&quot;, 
    &quot;Regina&quot;
)
</code></pre>
<p>You print its values using a <code>for</code> loop just like the previous example:</p>
<pre><code class="language-scala">for (p &lt;- people) println(p)
</code></pre>
<blockquote>
<p><code>Seq</code> and <code>List</code> are two types of linear collections. In Scala these collection classes are preferred over <code>Array</code>. (More on this later.)</p>
</blockquote>
<h2 id="the-foreach-method"><a class="header" href="#the-foreach-method">The foreach method</a></h2>
<p>For the purpose of iterating over a collection of elements and printing its contents you can also use the <code>foreach</code> method that’s available to Scala collections classes. For example, this is how you use <code>foreach</code> to print the previous list of strings:</p>
<pre><code class="language-scala">people.foreach(println)
</code></pre>
<p><code>foreach</code> is available on most collections classes, including sequences, maps, and sets.</p>
<h2 id="using-for-and-foreach-with-maps"><a class="header" href="#using-for-and-foreach-with-maps">Using <code>for</code> and <code>foreach</code> with Maps</a></h2>
<p>You can also use <code>for</code> and <code>foreach</code> when working with a Scala <code>Map</code> (which is similar to a Java <code>HashMap</code>). For example, given this <code>Map</code> of movie names and ratings:</p>
<pre><code class="language-scala">val ratings = Map(
    &quot;Lady in the Water&quot;  -&gt; 3.0, 
    &quot;Snakes on a Plane&quot;  -&gt; 4.0, 
    &quot;You, Me and Dupree&quot; -&gt; 3.5
)
</code></pre>
<p>You can print the movie names and ratings using <code>for</code> like this:</p>
<pre><code class="language-scala">for ((name,rating) &lt;- ratings) println(s&quot;Movie: $name, Rating: $rating&quot;)
</code></pre>
<p>Here’s what that looks like in the REPL:</p>
<pre><code class="language-scala">scala&gt; for ((name,rating) &lt;- ratings) println(s&quot;Movie: $name, Rating: $rating&quot;)
Movie: Lady in the Water, Rating: 3.0
Movie: Snakes on a Plane, Rating: 4.0
Movie: You, Me and Dupree, Rating: 3.5
</code></pre>
<p>In this example, <code>name</code> corresponds to each <em>key</em> in the map, and <code>rating</code> is the name that’s assigned to each <em>value</em> in the map.</p>
<p>You can also print the ratings with <code>foreach</code> like this:</p>
<pre><code class="language-scala">ratings.foreach {
    case(movie, rating) =&gt; println(s&quot;key: $movie, value: $rating&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: for Expressions
description: This page shows how to use Scala 'for' expressions (also known as 'for-expressions'), including examples of how to use it with the 'yield' keyword.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 16
outof: 54
previous-page: for-loops
next-page: match-expressions</h2>
<p>If you recall what we wrote about Expression-Oriented Programming (EOP) and the difference between <em>expressions</em> and <em>statements</em>, you’ll notice that in the previous lesson we used the <code>for</code> keyword and <code>foreach</code> method as tools for side effects. We used them to print the values in the collections to STDOUT using <code>println</code>. Java has similar keywords, and many programmers used them for years without ever giving much thought to how they could be improved.</p>
<p>Once you start working with Scala you’ll see that in functional programming languages you can use more powerful “<code>for</code> expressions” in addition to “<code>for</code> loops.” In Scala, a <code>for</code> expression — which we’ll write as for-expression — is a different use of the <code>for</code> construct. While a <em>for-loop</em> is used for side effects (such as printing output), a <em>for-expression</em> is used to create new collections from existing collections.</p>
<p>For example, given this list of integers:</p>
<pre><code class="language-scala">val nums = Seq(1,2,3)
</code></pre>
<p>You can create a new list of integers where all of the values are doubled, like this:</p>
<pre><code class="language-scala">val doubledNums = for (n &lt;- nums) yield n * 2
</code></pre>
<p>That expression can be read as, “For every number <code>n</code> in the list of numbers <code>nums</code>, double each value, and then assign all of the new values to the variable <code>doubledNums</code>.” This is what it looks like in the Scala REPL:</p>
<pre><code class="language-scala">scala&gt; val doubledNums = for (n &lt;- nums) yield n * 2
doubledNums: Seq[Int] = List(2, 4, 6)
</code></pre>
<p>As the REPL output shows, the new list <code>doubledNums</code> contains these values:</p>
<pre><code class="language-scala">List(2,4,6)
</code></pre>
<p>In summary, the result of the for-expression is that it creates a new variable named <code>doubledNums</code> whose values were created by doubling each value in the original list, <code>nums</code>.</p>
<h2 id="capitalizing-a-list-of-strings"><a class="header" href="#capitalizing-a-list-of-strings">Capitalizing a list of strings</a></h2>
<p>You can use the same approach with a list of strings. For example, given this list of lowercase strings:</p>
<pre><code class="language-scala">val names = List(&quot;adam&quot;, &quot;david&quot;, &quot;frank&quot;)
</code></pre>
<p>You can create a list of capitalized strings with this for-expression:</p>
<pre><code class="language-scala">val ucNames = for (name &lt;- names) yield name.capitalize
</code></pre>
<p>The REPL shows how this works:</p>
<pre><code class="language-scala">scala&gt; val ucNames = for (name &lt;- names) yield name.capitalize
ucNames: List[String] = List(Adam, David, Frank)
</code></pre>
<p>Success! Each name in the new variable <code>ucNames</code> is capitalized.</p>
<h2 id="the-yield-keyword"><a class="header" href="#the-yield-keyword">The <code>yield</code> keyword</a></h2>
<p>Notice that both of those for-expressions use the <code>yield</code> keyword:</p>
<pre><code class="language-scala">val doubledNums = for (n &lt;- nums) yield n * 2
                                  -----

val ucNames = for (name &lt;- names) yield name.capitalize
                                  -----
</code></pre>
<p>Using <code>yield</code> after <code>for</code> is the “secret sauce” that says, “I want to yield a new collection from the existing collection that I’m iterating over in the for-expression, using the algorithm shown.”</p>
<h2 id="using-a-block-of-code-after-yield"><a class="header" href="#using-a-block-of-code-after-yield">Using a block of code after <code>yield</code></a></h2>
<p>The code after the <code>yield</code> expression can be as long as necessary to solve the current problem. For example, given a list of strings like this:</p>
<pre><code class="language-scala">val names = List(&quot;_adam&quot;, &quot;_david&quot;, &quot;_frank&quot;)
</code></pre>
<p>Imagine that you want to create a new list that has the capitalized names of each person. To do that, you first need to remove the underscore character at the beginning of each name, and then capitalize each name. To remove the underscore from each name, you call <code>drop(1)</code> on each <code>String</code>. After you do that, you call the <code>capitalize</code> method on each string. Here’s how you can use a for-expression to solve this problem:</p>
<pre><code class="language-scala">val capNames = for (name &lt;- names) yield {
    val nameWithoutUnderscore = name.drop(1)
    val capName = nameWithoutUnderscore.capitalize
    capName
}
</code></pre>
<p>If you put that code in the REPL, you’ll see this result:</p>
<pre><code class="language-scala">capNames: List[String] = List(Adam, David, Frank)
</code></pre>
<h3 id="a-shorter-version-of-the-solution"><a class="header" href="#a-shorter-version-of-the-solution">A shorter version of the solution</a></h3>
<p>We show the verbose form of the solution in that example so you can see how to use multiple lines of code after <code>yield</code>. However, for this particular example you can also write the code like this, which is more of the Scala style:</p>
<pre><code class="language-scala">val capNames = for (name &lt;- names) yield name.drop(1).capitalize
</code></pre>
<p>You can also put curly braces around the algorithm, if you prefer:</p>
<pre><code class="language-scala">val capNames = for (name &lt;- names) yield { name.drop(1).capitalize }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: match Expressions
description: This page shows examples of the Scala 'match' expression, including how to write match/case expressions.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 17
outof: 54
previous-page: for-expressions
next-page: try-catch-finally</h2>
<p>Scala has a concept of a <code>match</code> expression. In the most simple case you can use a <code>match</code> expression like a Java <code>switch</code> statement:</p>
<pre><code class="language-scala">// i is an integer
i match {
    case 1  =&gt; println(&quot;January&quot;)
    case 2  =&gt; println(&quot;February&quot;)
    case 3  =&gt; println(&quot;March&quot;)
    case 4  =&gt; println(&quot;April&quot;)
    case 5  =&gt; println(&quot;May&quot;)
    case 6  =&gt; println(&quot;June&quot;)
    case 7  =&gt; println(&quot;July&quot;)
    case 8  =&gt; println(&quot;August&quot;)
    case 9  =&gt; println(&quot;September&quot;)
    case 10 =&gt; println(&quot;October&quot;)
    case 11 =&gt; println(&quot;November&quot;)
    case 12 =&gt; println(&quot;December&quot;)
    // catch the default with a variable so you can print it
    case _  =&gt; println(&quot;Invalid month&quot;)
}
</code></pre>
<p>As shown, with a <code>match</code> expression you write a number of <code>case</code> statements that you use to match possible values. In this example we match the integer values <code>1</code> through <code>12</code>. Any other value falls down to the <code>_</code> case, which is the catch-all, default case.</p>
<p><code>match</code> expressions are nice because they also return values, so rather than directly printing a string as in that example, you can assign the string result to a new value:</p>
<pre><code class="language-scala">val monthName = i match {
    case 1  =&gt; &quot;January&quot;
    case 2  =&gt; &quot;February&quot;
    case 3  =&gt; &quot;March&quot;
    case 4  =&gt; &quot;April&quot;
    case 5  =&gt; &quot;May&quot;
    case 6  =&gt; &quot;June&quot;
    case 7  =&gt; &quot;July&quot;
    case 8  =&gt; &quot;August&quot;
    case 9  =&gt; &quot;September&quot;
    case 10 =&gt; &quot;October&quot;
    case 11 =&gt; &quot;November&quot;
    case 12 =&gt; &quot;December&quot;
    case _  =&gt; &quot;Invalid month&quot;
}
</code></pre>
<p>Using a <code>match</code> expression to yield a result like this is a common use.</p>
<h2 id="aside-a-quick-look-at-scala-methods"><a class="header" href="#aside-a-quick-look-at-scala-methods">Aside: A quick look at Scala methods</a></h2>
<p>Scala also makes it easy to use a <code>match</code> expression as the body of a method. We haven’t shown how to write Scala methods yet, so as a brief introduction, here’s a method named <code>convertBooleanToStringMessage</code> that takes a <code>Boolean</code> value and returns a <code>String</code>:</p>
<pre><code class="language-scala">def convertBooleanToStringMessage(bool: Boolean): String = {
    if (bool) &quot;true&quot; else &quot;false&quot;        
}
</code></pre>
<p>Hopefully you can see how that method works, even though we won’t go into its details. These examples show how it works when you give it the <code>Boolean</code> values <code>true</code> and <code>false</code>:</p>
<pre><code class="language-scala">scala&gt; val answer = convertBooleanToStringMessage(true)
answer: String = true

scala&gt; val answer = convertBooleanToStringMessage(false)
answer: String = false
</code></pre>
<h2 id="using-a-match-expression-as-the-body-of-a-method"><a class="header" href="#using-a-match-expression-as-the-body-of-a-method">Using a <code>match</code> expression as the body of a method</a></h2>
<p>Now that you’ve seen an example of a Scala method, here’s a second example that works just like the previous one, taking a <code>Boolean</code> value as an input parameter and returning a <code>String</code> message. The big difference is that this method uses a <code>match</code> expression for the body of the method:</p>
<pre><code class="language-scala">def convertBooleanToStringMessage(bool: Boolean): String = bool match {
    case true =&gt; &quot;you said true&quot;
    case false =&gt; &quot;you said false&quot;
}
</code></pre>
<p>The body of that method is just two <code>case</code> statements, one that matches <code>true</code> and another that matches <code>false</code>. Because those are the only possible <code>Boolean</code> values, there’s no need for a default <code>case</code> statement.</p>
<p>This is how you call that method and then print its result:</p>
<pre><code class="language-scala">val result = convertBooleanToStringMessage(true)
println(result)
</code></pre>
<p>Using a <code>match</code> expression as the body of a method is also a common use.</p>
<h2 id="handling-alternate-cases"><a class="header" href="#handling-alternate-cases">Handling alternate cases</a></h2>
<p><code>match</code> expressions are extremely powerful, and we’ll demonstrate a few other things you can do with them.</p>
<p><code>match</code> expressions let you handle multiple cases in a single <code>case</code> statement. To demonstrate this, imagine that you want to evaluate “boolean equality” like the Perl programming language handles it: a <code>0</code> or a blank string evaluates to false, and anything else evaluates to true. This is how you write a method using a <code>match</code> expression that evaluates to true and false in the manner described:</p>
<pre><code class="language-scala">def isTrue(a: Any) = a match {
    case 0 | &quot;&quot; =&gt; false
    case _ =&gt; true
}
</code></pre>
<p>Because the input parameter <code>a</code> is defined to be the <code>Any</code> type — which is the root of all Scala classes, like <code>Object</code> in Java — this method works with any data type that’s passed in:</p>
<pre><code class="language-scala">scala&gt; isTrue(0)
res0: Boolean = false

scala&gt; isTrue(&quot;&quot;)
res1: Boolean = false

scala&gt; isTrue(1.1F)
res2: Boolean = true

scala&gt; isTrue(new java.io.File(&quot;/etc/passwd&quot;))
res3: Boolean = true
</code></pre>
<p>The key part of this solution is that this one <code>case</code> statement lets both <code>0</code> and the empty string evaluate to <code>false</code>:</p>
<pre><code class="language-scala">case 0 | &quot;&quot; =&gt; false
</code></pre>
<p>Before we move on, here’s another example that shows many matches in each <code>case</code> statement:</p>
<pre><code class="language-scala">val evenOrOdd = i match {
    case 1 | 3 | 5 | 7 | 9 =&gt; println(&quot;odd&quot;)
    case 2 | 4 | 6 | 8 | 10 =&gt; println(&quot;even&quot;)
    case _ =&gt; println(&quot;some other number&quot;)
}
</code></pre>
<p>Here’s another example that shows how to handle multiple strings in multiple <code>case</code> statements:</p>
<pre><code class="language-scala">cmd match {
    case &quot;start&quot; | &quot;go&quot; =&gt; println(&quot;starting&quot;)
    case &quot;stop&quot; | &quot;quit&quot; | &quot;exit&quot; =&gt; println(&quot;stopping&quot;)
    case _ =&gt; println(&quot;doing nothing&quot;)
}
</code></pre>
<h2 id="using-if-expressions-in-case-statements"><a class="header" href="#using-if-expressions-in-case-statements">Using <code>if</code> expressions in <code>case</code> statements</a></h2>
<p>Another great thing about <code>match</code> expressions is that you can use <code>if</code> expressions in <code>case</code> statements for powerful pattern matching. In this example the second and third <code>case</code> statements both use <code>if</code> expressions to match ranges of numbers:</p>
<pre><code class="language-scala">count match {
    case 1 =&gt; println(&quot;one, a lonely number&quot;)
    case x if x == 2 || x == 3 =&gt; println(&quot;two's company, three's a crowd&quot;)
    case x if x &gt; 3 =&gt; println(&quot;4+, that's a party&quot;)
    case _ =&gt; println(&quot;i'm guessing your number is zero or less&quot;)
}
</code></pre>
<p>Scala doesn’t require you to use parentheses in the <code>if</code> expressions, but you can use them if you think that makes them more readable:</p>
<pre><code class="language-scala">count match {
    case 1 =&gt; println(&quot;one, a lonely number&quot;)
    case x if (x == 2 || x == 3) =&gt; println(&quot;two's company, three's a crowd&quot;)
    case x if (x &gt; 3) =&gt; println(&quot;4+, that's a party&quot;)
    case _ =&gt; println(&quot;i'm guessing your number is zero or less&quot;)
}
</code></pre>
<p>You can also write the code on the right side of the <code>=&gt;</code> on multiple lines if you think is easier to read. Here’s one example:</p>
<pre><code class="language-scala">count match {
    case 1 =&gt; 
        println(&quot;one, a lonely number&quot;)
    case x if x == 2 || x == 3 =&gt; 
        println(&quot;two's company, three's a crowd&quot;)
    case x if x &gt; 3 =&gt; 
        println(&quot;4+, that's a party&quot;)
    case _ =&gt; 
        println(&quot;i'm guessing your number is zero or less&quot;)
}
</code></pre>
<p>Here’s a variation of that example that uses curly braces:</p>
<pre><code class="language-scala">count match {
    case 1 =&gt; {
        println(&quot;one, a lonely number&quot;)
    }
    case x if x == 2 || x == 3 =&gt; {
        println(&quot;two's company, three's a crowd&quot;)
    }
    case x if x &gt; 3 =&gt; {
        println(&quot;4+, that's a party&quot;)
    }
    case _ =&gt; {
        println(&quot;i'm guessing your number is zero or less&quot;)
    }
}
</code></pre>
<p>Here are a few other examples of how you can use <code>if</code> expressions in <code>case</code> statements. First, another example of how to match ranges of numbers:</p>
<pre><code class="language-scala">i match {
  case a if 0 to 9 contains a =&gt; println(&quot;0-9 range: &quot; + a)
  case b if 10 to 19 contains b =&gt; println(&quot;10-19 range: &quot; + b)
  case c if 20 to 29 contains c =&gt; println(&quot;20-29 range: &quot; + c)
  case _ =&gt; println(&quot;Hmmm...&quot;)
}
</code></pre>
<p>Lastly, this example shows how to reference class fields in <code>if</code> expressions:</p>
<pre><code class="language-scala">stock match {
  case x if (x.symbol == &quot;XYZ&quot; &amp;&amp; x.price &lt; 20) =&gt; buy(x)
  case x if (x.symbol == &quot;XYZ&quot; &amp;&amp; x.price &gt; 50) =&gt; sell(x)
  case x =&gt; doNothing(x)
}
</code></pre>
<h2 id="even-more"><a class="header" href="#even-more">Even more</a></h2>
<p><code>match</code> expressions are very powerful, and there are even more things you can do with them, but hopefully these examples provide a good start towards using them.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: try/catch/finally Expressions
description: This page shows how to use Scala's try/catch/finally construct, including several complete examples.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 18
outof: 54
previous-page: match-expressions
next-page: classes</h2>
<p>Like Java, Scala has a try/catch/finally construct to let you catch and manage exceptions. The main difference is that for consistency, Scala uses the same syntax that <code>match</code> expressions use: <code>case</code> statements to match the different possible exceptions that can occur.</p>
<h2 id="a-trycatch-example"><a class="header" href="#a-trycatch-example">A try/catch example</a></h2>
<p>Here’s an example of Scala’s try/catch syntax. In this example, <code>openAndReadAFile</code> is a method that does what its name implies: it opens a file and reads the text in it, assigning the result to the variable named <code>text</code>:</p>
<pre><code class="language-scala">var text = &quot;&quot;
try {
    text = openAndReadAFile(filename)
} catch {
    case e: FileNotFoundException =&gt; println(&quot;Couldn't find that file.&quot;)
    case e: IOException =&gt; println(&quot;Had an IOException trying to read that file&quot;)
}
</code></pre>
<p>Scala uses the <em>java.io.*</em> classes to work with files, so attempting to open and read a file can result in both a <code>FileNotFoundException</code> and an <code>IOException</code>. Those two exceptions are caught in the <code>catch</code> block of this example.</p>
<h2 id="try-catch-and-finally"><a class="header" href="#try-catch-and-finally">try, catch, and finally</a></h2>
<p>The Scala try/catch syntax also lets you use a <code>finally</code> clause, which is typically used when you need to close a resource. Here’s an example of what that looks like:</p>
<pre><code class="language-scala">try {
    // your scala code here
} 
catch {
    case foo: FooException =&gt; handleFooException(foo)
    case bar: BarException =&gt; handleBarException(bar)
    case _: Throwable =&gt; println(&quot;Got some other kind of Throwable exception&quot;)
} finally {
    // your scala code here, such as closing a database connection
    // or file handle
}
</code></pre>
<h2 id="more-later"><a class="header" href="#more-later">More later</a></h2>
<p>We’ll cover more details about Scala’s try/catch/finally syntax in later lessons, such as in the “Functional Error Handling” lessons, but these examples demonstrate how the syntax works. A great thing about the syntax is that it’s consistent with the <code>match</code> expression syntax. This makes your code consistent and easier to read, and you don’t have to remember a special/different syntax.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: Scala Classes
description: This page shows examples of how to create Scala classes, including the basic Scala class constructor.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 19
outof: 54
previous-page: try-catch-finally
next-page: classes-aux-constructors</h2>
<p>In support of object-oriented programming (OOP), Scala provides a <em>class</em> construct. The syntax is much more concise than languages like Java and C#, but it’s also still easy to use and read.</p>
<h2 id="basic-class-constructor"><a class="header" href="#basic-class-constructor">Basic class constructor</a></h2>
<p>Here’s a Scala class whose constructor defines two parameters, <code>firstName</code> and <code>lastName</code>:</p>
<pre><code class="language-scala">class Person(var firstName: String, var lastName: String)
</code></pre>
<p>Given that definition, you can create new <code>Person</code> instances like this:</p>
<pre><code class="language-scala">val p = new Person(&quot;Bill&quot;, &quot;Panner&quot;)
</code></pre>
<p>Defining parameters in a class constructor automatically creates fields in the class, and in this example you can access the <code>firstName</code> and <code>lastName</code> fields like this:</p>
<pre><code class="language-scala">println(p.firstName + &quot; &quot; + p.lastName)
Bill Panner
</code></pre>
<p>In this example, because both fields are defined as <code>var</code> fields, they’re also mutable, meaning they can be changed. This is how you change them:</p>
<pre><code class="language-scala">scala&gt; p.firstName = &quot;William&quot;
p.firstName: String = William

scala&gt; p.lastName = &quot;Bernheim&quot;
p.lastName: String = Bernheim
</code></pre>
<p>If you’re coming to Scala from Java, this Scala code:</p>
<pre><code class="language-scala">class Person(var firstName: String, var lastName: String)
</code></pre>
<p>is roughly the equivalent of this Java code:</p>
<pre><code class="language-java">public class Person {

    private String firstName;
    private String lastName;
    
    public Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    
    public String getFirstName() {
        return this.firstName;
    }
    
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
    
    public String getLastName() {
        return this.lastName;
    }
    
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
    
}
</code></pre>
<h2 id="val-makes-fields-read-only"><a class="header" href="#val-makes-fields-read-only"><code>val</code> makes fields read-only</a></h2>
<p>In that first example both fields were defined as <code>var</code> fields:</p>
<pre><code class="language-scala">class Person(var firstName: String, var lastName: String)
</code></pre>
<p>That makes those fields mutable. You can also define them as <code>val</code> fields, which makes them immutable:</p>
<pre><code class="language-scala">class Person(val firstName: String, val lastName: String)
             ---                    ---
</code></pre>
<p>If you now try to change the first or last name of a <code>Person</code> instance, you’ll see an error:</p>
<pre><code class="language-scala">scala&gt; p.firstName = &quot;Fred&quot;
&lt;console&gt;:12: error: reassignment to val
       p.firstName = &quot;Fred&quot;
                   ^

scala&gt; p.lastName = &quot;Jones&quot;
&lt;console&gt;:12: error: reassignment to val
       p.lastName = &quot;Jones&quot;
                  ^
</code></pre>
<blockquote>
<p>Tip: If you use Scala to write OOP code, create your fields as <code>var</code> fields so you can mutate them. When you write FP code with Scala, you’ll generally use <em>case classes</em> instead of classes like this. (More on this later.)</p>
</blockquote>
<h2 id="class-constructors"><a class="header" href="#class-constructors">Class constructors</a></h2>
<p>In Scala, the primary constructor of a class is a combination of:</p>
<ul>
<li>The constructor parameters</li>
<li>Methods that are called in the body of the class</li>
<li>Statements and expressions that are executed in the body of the class</li>
</ul>
<p>Fields declared in the body of a Scala class are handled in a manner similar to Java; they’re assigned when the class is first instantiated.</p>
<p>This <code>Person</code> class demonstrates several of the things you can do inside the body of a class:</p>
<pre><code class="language-scala">class Person(var firstName: String, var lastName: String) {

    println(&quot;the constructor begins&quot;)

    // 'public' access by default
    var age = 0

    // some class fields
    private val HOME = System.getProperty(&quot;user.home&quot;)

    // some methods
    override def toString(): String = s&quot;$firstName $lastName is $age years old&quot;

    def printHome(): Unit = println(s&quot;HOME = $HOME&quot;)    
    def printFullName(): Unit = println(this) 

    printHome()
    printFullName()
    println(&quot;you've reached the end of the constructor&quot;)

}
</code></pre>
<p>This code in the Scala REPL demonstrates how this class works:</p>
<pre><code class="language-scala">scala&gt; val p = new Person(&quot;Kim&quot;, &quot;Carnes&quot;)
the constructor begins
HOME = /Users/al
Kim Carnes is 0 years old
you've reached the end of the constructor
p: Person = Kim Carnes is 0 years old

scala&gt; p.age
res0: Int = 0

scala&gt; p.age = 36
p.age: Int = 36

scala&gt; p
res1: Person = Kim Carnes is 36 years old

scala&gt; p.printHome
HOME = /Users/al

scala&gt; p.printFullName
Kim Carnes is 36 years old
</code></pre>
<p>When you come to Scala from a more verbose language this constructor approach might feel a little unusual at first, but once you understand and write a couple of classes with it, you’ll find it to be logical and convenient.</p>
<h2 id="other-scala-class-examples"><a class="header" href="#other-scala-class-examples">Other Scala class examples</a></h2>
<p>Before we move on, here are a few other examples of Scala classes:</p>
<pre><code class="language-scala">class Pizza (var crustSize: Int, var crustType: String)

// a stock, like AAPL or GOOG
class Stock(var symbol: String, var price: BigDecimal)

// a network socket
class Socket(val timeout: Int, val linger: Int) {
    override def toString = s&quot;timeout: $timeout, linger: $linger&quot;
}

class Address (
    var street1: String,
    var street2: String,
    var city: String, 
    var state: String
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Auxiliary Class Constructors
description: This page shows how to write auxiliary Scala class constructors, including several examples of the syntax.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 20
outof: 54
previous-page: classes
next-page: constructors-default-values</h2>
<p>You define auxiliary Scala class constructors by defining methods that are named <code>this</code>. There are only a few rules to know:</p>
<ul>
<li>Each auxiliary constructor must have a different signature (different parameter lists)</li>
<li>Each constructor must call one of the previously defined constructors</li>
</ul>
<p>Here’s an example of a <code>Pizza</code> class that defines multiple constructors:</p>
<pre><code class="language-scala">val DefaultCrustSize = 12
val DefaultCrustType = &quot;THIN&quot;

// the primary constructor
class Pizza (var crustSize: Int, var crustType: String) {

    // one-arg auxiliary constructor
    def this(crustSize: Int) = {
        this(crustSize, DefaultCrustType)
    }

    // one-arg auxiliary constructor
    def this(crustType: String) = {
        this(DefaultCrustSize, crustType)
    }

    // zero-arg auxiliary constructor
    def this() = {
        this(DefaultCrustSize, DefaultCrustType)
    }

    override def toString = s&quot;A $crustSize inch pizza with a $crustType crust&quot;

}
</code></pre>
<p>With all of those constructors defined, you can create pizza instances in several different ways:</p>
<pre><code class="language-scala">val p1 = new Pizza(DefaultCrustSize, DefaultCrustType)
val p2 = new Pizza(DefaultCrustSize)
val p3 = new Pizza(DefaultCrustType)
val p4 = new Pizza
</code></pre>
<p>We encourage you to paste that class and those examples into the Scala REPL to see how they work.</p>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p>There are two important notes to make about this example:</p>
<ul>
<li>The <code>DefaultCrustSize</code> and <code>DefaultCrustType</code> variables are not a preferred way to handle this situation, but because we haven’t shown how to handle enumerations yet, we use this approach to keep things simple.</li>
<li>Auxiliary class constructors are a great feature, but because you can use default values for constructor parameters, you won’t need to use this feature very often. The next lesson demonstrates how using default parameter values like this often makes auxiliary constructors unnecessary:</li>
</ul>
<pre><code class="language-scala">class Pizza(
    var crustSize: Int = DefaultCrustSize, 
    var crustType: String = DefaultCrustType
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Supplying Default Values for Constructor Parameters
description: This page shows how to provide default values for Scala constructor parameters, with several examples.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 21
outof: 54
previous-page: classes-aux-constructors
next-page: methods-first-look</h2>
<p>Scala lets you supply default values for constructor parameters. For example, in previous lessons we showed that you can define a <code>Socket</code> class like this:</p>
<pre><code class="language-scala">class Socket(var timeout: Int, var linger: Int) {
    override def toString = s&quot;timeout: $timeout, linger: $linger&quot;
}
</code></pre>
<p>That’s nice, but you can make this class better by supplying default values for the <code>timeout</code> and <code>linger</code> parameters:</p>
<pre><code class="language-scala">class Socket(var timeout: Int = 2000, var linger: Int = 3000) {
    override def toString = s&quot;timeout: $timeout, linger: $linger&quot;
}
</code></pre>
<p>By supplying default values for the parameters, you can now create a new <code>Socket</code> in a variety of different ways:</p>
<pre><code class="language-scala">new Socket()
new Socket(1000)
new Socket(4000, 6000)
</code></pre>
<p>Here’s what those examples look like in the REPL:</p>
<pre><code class="language-scala">scala&gt; new Socket()
res0: Socket = timeout: 2000, linger: 3000

scala&gt; new Socket(1000)
res1: Socket = timeout: 1000, linger: 3000

scala&gt; new Socket(4000, 6000)
res2: Socket = timeout: 4000, linger: 6000
</code></pre>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<p>Supplying default constructor parameters has at least two benefits:</p>
<ul>
<li>You provide preferred, default values for your parameters</li>
<li>You let consumers of your class override those values for their own needs</li>
</ul>
<p>As shown in the examples, a third benefit is that it lets consumers construct new <code>Socket</code> instances in at least three different ways, as if it had three class constructors.</p>
<h2 id="bonus-named-parameters"><a class="header" href="#bonus-named-parameters">Bonus: Named parameters</a></h2>
<p>Another nice thing about Scala is that you can use named parameters when creating a new instance of a class. For instance, given this class:</p>
<pre><code class="language-scala">class Socket(var timeout: Int, var linger: Int) {
    override def toString = s&quot;timeout: $timeout, linger: $linger&quot;
}
</code></pre>
<p>you can create a new <code>Socket</code> like this:</p>
<pre><code class="language-scala">val s = new Socket(timeout=2000, linger=3000)
</code></pre>
<p>This feature comes in handy from time to time, such as when all of the class constructor parameters have the same type, such as the <code>Int</code> parameters in this example. For example, some people find that this code:</p>
<pre><code class="language-scala">val s = new Socket(timeout=2000, linger=3000)
</code></pre>
<p>is more readable than this code:</p>
<pre><code class="language-scala">val s = new Socket(2000, 3000)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: A First Look at Scala Methods
description: This page provides a first look at how to write Scala methods, including how to test them in the REPL.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 22
outof: 54
previous-page: constructors-default-values
next-page: enumerations-pizza-class</h2>
<p>In Scala, <em>methods</em> are defined inside classes (just like Java), but for testing purposes you can also create them in the REPL. This lesson will show some examples of methods so you can see what the syntax looks like.</p>
<h2 id="defining-a-method-that-takes-one-input-parameter"><a class="header" href="#defining-a-method-that-takes-one-input-parameter">Defining a method that takes one input parameter</a></h2>
<p>This is how you define a method named <code>double</code> that takes one integer input parameter named <code>a</code> and returns the doubled value of that integer:</p>
<pre><code class="language-scala">def double(a: Int) = a * 2
</code></pre>
<p>In that example the method name and signature are shown on the left side of the <code>=</code> sign:</p>
<pre><code>def double(a: Int) = a * 2
    --------------
</code></pre>
<p><code>def</code> is the keyword you use to define a method, the method name is <code>double</code>, and the input parameter <code>a</code> has the type <code>Int</code>, which is Scala’s integer data type.</p>
<p>The body of the function is shown on the right side, and in this example it simply doubles the value of the input parameter <code>a</code>:</p>
<pre><code>def double(a: Int) = a * 2
                     -----
</code></pre>
<p>After you paste that method into the REPL, you can call it (invoke it) by giving it an <code>Int</code> value:</p>
<pre><code class="language-scala">scala&gt; double(2)
res0: Int = 4

scala&gt; double(10)
res1: Int = 20
</code></pre>
<h2 id="showing-the-methods-return-type"><a class="header" href="#showing-the-methods-return-type">Showing the method’s return type</a></h2>
<p>The previous example didn’t show the method’s return type, but you can show it:</p>
<pre><code class="language-scala">def double(a: Int): Int = a * 2
                  -----
</code></pre>
<p>Writing a method like this <em>explicitly</em> declares the method’s return type. Some people prefer to explicitly declare method return types because it makes the code easier to maintain weeks, months, and years in the future.</p>
<p>If you paste that method into the REPL, you’ll see that it works just like the previous method.</p>
<h2 id="methods-with-multiple-input-parameters"><a class="header" href="#methods-with-multiple-input-parameters">Methods with multiple input parameters</a></h2>
<p>To show something a little more complex, here’s a method that takes two input parameters:</p>
<pre><code class="language-scala">def add(a: Int, b: Int) = a + b
</code></pre>
<p>Here’s the same method, with the method’s return type explicitly shown:</p>
<pre><code class="language-scala">def add(a: Int, b: Int): Int = a + b
</code></pre>
<p>Here’s a method that takes three input parameters:</p>
<pre><code class="language-scala">def add(a: Int, b: Int, c: Int): Int = a + b + c
</code></pre>
<h2 id="multiline-methods"><a class="header" href="#multiline-methods">Multiline methods</a></h2>
<p>When a method is only one line long you can use the format shown, but when the method body gets longer, you put the multiple lines inside curly braces:</p>
<pre><code class="language-scala">def addThenDouble(a: Int, b: Int): Int = {
    val sum = a + b
    val doubled = sum * 2
    doubled
}
</code></pre>
<p>If you paste that code into the REPL, you’ll see that it works just like the previous examples:</p>
<pre><code class="language-scala">scala&gt; addThenDouble(1, 1)
res0: Int = 4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Enumerations (and a Complete Pizza Class)
description: This page introduces Scala enumerations, and further shows how to create a complete OOP 'Pizza' class that uses those enumerations.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 23
outof: 54
previous-page: methods-first-look
next-page: traits-intro</h2>
<p>If we demonstrate enumerations next, we can also show you what an example <code>Pizza</code> class looks like when written in an object-oriented manner. So that’s the path we’ll take.</p>
<p><em>Enumerations</em> are a useful tool for creating small groups of constants, things like the days of the week, months in a year, suits in a deck of cards, etc., situations where you have a group of related, constant values.</p>
<p>Because we’re jumping ahead a little bit, we’re not going to explain this syntax too much, but this is how you create an enumeration for the days of a week:</p>
<pre><code class="language-scala">sealed trait DayOfWeek
case object Sunday extends DayOfWeek
case object Monday extends DayOfWeek
case object Tuesday extends DayOfWeek
case object Wednesday extends DayOfWeek
case object Thursday extends DayOfWeek
case object Friday extends DayOfWeek
case object Saturday extends DayOfWeek
</code></pre>
<p>As shown, just declare a base trait and then extend that trait with as many case objects as needed.</p>
<p>Similarly, this is how you create an enumeration for the suits in a deck of cards:</p>
<pre><code class="language-scala">sealed trait Suit
case object Clubs extends Suit
case object Spades extends Suit
case object Diamonds extends Suit
case object Hearts extends Suit
</code></pre>
<p>We’ll discuss traits and case objects later in this book, but if you’ll trust us for now that this is how you create enumerations, we can then create a little OOP version of a <code>Pizza</code> class in Scala.</p>
<h2 id="pizza-related-enumerations"><a class="header" href="#pizza-related-enumerations">Pizza-related enumerations</a></h2>
<p>Given that (very brief) introduction to enumerations, we can now create pizza-related enumerations like this:</p>
<pre><code class="language-scala">sealed trait Topping
case object Cheese extends Topping
case object Pepperoni extends Topping
case object Sausage extends Topping
case object Mushrooms extends Topping
case object Onions extends Topping

sealed trait CrustSize
case object SmallCrustSize extends CrustSize
case object MediumCrustSize extends CrustSize
case object LargeCrustSize extends CrustSize

sealed trait CrustType
case object RegularCrustType extends CrustType
case object ThinCrustType extends CrustType
case object ThickCrustType extends CrustType
</code></pre>
<p>Those enumerations provide a nice way to work with pizza toppings, crust sizes, and crust types.</p>
<h2 id="a-sample-pizza-class"><a class="header" href="#a-sample-pizza-class">A sample Pizza class</a></h2>
<p>Given those enumerations, we can define a <code>Pizza</code> class like this:</p>
<pre><code class="language-scala">class Pizza (
    var crustSize: CrustSize = MediumCrustSize, 
    var crustType: CrustType = RegularCrustType
) {

    // ArrayBuffer is a mutable sequence (list)
    val toppings = scala.collection.mutable.ArrayBuffer[Topping]()

    def addTopping(t: Topping): Unit = toppings += t
    def removeTopping(t: Topping): Unit = toppings -= t
    def removeAllToppings(): Unit = toppings.clear()

}
</code></pre>
<p>If you save all of that code — including the enumerations — in a file named <em>Pizza.scala</em>, you’ll see that you can compile it with the usual command:</p>
<pre><code class="language-sh">$ scalac Pizza.scala
</code></pre>
<blockquote>
<p>That code will create a lot of individual files, so we recommend putting it in a separate directory.</p>
</blockquote>
<p>There’s nothing to run yet because this class doesn’t have a <code>main</code> method, but ...</p>
<h2 id="a-complete-pizza-class-with-a-main-method"><a class="header" href="#a-complete-pizza-class-with-a-main-method">A complete Pizza class with a main method</a></h2>
<p>If you’re ready to have some fun, copy all of the following source code and paste it into a file named <em>Pizza.scala</em>:</p>
<pre><code class="language-scala">import scala.collection.mutable.ArrayBuffer

sealed trait Topping
case object Cheese extends Topping
case object Pepperoni extends Topping
case object Sausage extends Topping
case object Mushrooms extends Topping
case object Onions extends Topping

sealed trait CrustSize
case object SmallCrustSize extends CrustSize
case object MediumCrustSize extends CrustSize
case object LargeCrustSize extends CrustSize

sealed trait CrustType
case object RegularCrustType extends CrustType
case object ThinCrustType extends CrustType
case object ThickCrustType extends CrustType

class Pizza (
    var crustSize: CrustSize = MediumCrustSize, 
    var crustType: CrustType = RegularCrustType
) {

    // ArrayBuffer is a mutable sequence (list)
    val toppings = ArrayBuffer[Topping]()

    def addTopping(t: Topping): Unit = toppings += t
    def removeTopping(t: Topping): Unit = toppings -= t
    def removeAllToppings(): Unit = toppings.clear()

    override def toString(): String = {
        s&quot;&quot;&quot;
        |Crust Size: $crustSize
        |Crust Type: $crustType
        |Toppings:   $toppings
        &quot;&quot;&quot;.stripMargin
    }
}

// a little &quot;driver&quot; app
object PizzaTest extends App {
   val p = new Pizza
   p.addTopping(Cheese)
   p.addTopping(Pepperoni)
   println(p)
}
</code></pre>
<p>Notice how you can put all of the enumerations, a <code>Pizza</code> class, and a <code>PizzaTest</code> object in the same file. That’s a very convenient Scala feature.</p>
<p>Next, compile that code with the usual command:</p>
<pre><code class="language-sh">$ scalac Pizza.scala
</code></pre>
<p>Now, run the <code>PizzaTest</code> object with this command:</p>
<pre><code class="language-sh">$ scala PizzaTest
</code></pre>
<p>The output should look like this:</p>
<pre><code class="language-sh">$ scala PizzaTest

Crust Size: MediumCrustSize
Crust Type: RegularCrustType
Toppings:   ArrayBuffer(Cheese, Pepperoni)
</code></pre>
<p>That code combines several different concepts — including two things we haven’t discussed yet in the <code>import</code> statement and the <code>ArrayBuffer</code> — but if you have experience with Java and other languages, hopefully it’s not too much to throw at you at one time.</p>
<p>At this point we encourage you to work with that code as desired. Make changes to the code, and try using the <code>removeTopping</code> and <code>removeAllToppings</code> methods to make sure they work the way you expect them to work.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: Scala Traits and Abstract Classes
description: An introduction to Scala traits and abstract classes.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 24
outof: 54
previous-page: enumerations-pizza-class
next-page: traits-interfaces</h2>
<p>Scala traits are a great feature of the language. As you’ll see in the following lessons, you can use them just like a Java interface, and you can also use them like abstract classes that have real methods. Scala classes can also extend and “mix in” multiple traits.</p>
<p>Scala also has the concept of an abstract class, and we’ll show when you should use an abstract class instead of a trait.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Using Scala Traits as Interfaces
description: This page shows how to use Scala traits just like Java interfaces, including several examples.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 25
outof: 54
previous-page: traits-intro
next-page: traits-abstract-mixins</h2>
<h2 id="using-scala-traits-as-interfaces"><a class="header" href="#using-scala-traits-as-interfaces">Using Scala Traits as Interfaces</a></h2>
<p>One way to use a Scala <code>trait</code> is like the original Java <code>interface</code>, where you define the desired interface for some piece of functionality, but you don’t implement any behavior.</p>
<h2 id="a-simple-example"><a class="header" href="#a-simple-example">A simple example</a></h2>
<p>As an example to get us started, imagine that you want to write some code to model animals like dogs and cats, any animal that has a tail. In Scala you write a trait to start that modeling process like this:</p>
<pre><code class="language-scala">trait TailWagger {
    def startTail(): Unit
    def stopTail(): Unit
}
</code></pre>
<p>That code declares a trait named <code>TailWagger</code> that states that any class that extends <code>TailWagger</code> should implement <code>startTail</code> and <code>stopTail</code> methods. Both of those methods take no input parameters and have no return value. This code is equivalent to this Java interface:</p>
<pre><code class="language-java">public interface TailWagger {
    public void startTail();
    public void stopTail();
}
</code></pre>
<h2 id="extending-a-trait"><a class="header" href="#extending-a-trait">Extending a trait</a></h2>
<p>Given this trait:</p>
<pre><code class="language-scala">trait TailWagger {
    def startTail(): Unit
    def stopTail(): Unit
}
</code></pre>
<p>you can write a class that extends the trait and implements those methods like this:</p>
<pre><code class="language-scala">class Dog extends TailWagger {
    // the implemented methods
    def startTail(): Unit = println(&quot;tail is wagging&quot;)
    def stopTail(): Unit = println(&quot;tail is stopped&quot;)
}
</code></pre>
<p>You can also write those methods like this, if you prefer:</p>
<pre><code class="language-scala">class Dog extends TailWagger {
    def startTail() = println(&quot;tail is wagging&quot;)
    def stopTail() = println(&quot;tail is stopped&quot;)
}
</code></pre>
<p>Notice that in either case, you use the <code>extends</code> keyword to create a class that extends a single trait:</p>
<pre><code class="language-scala">class Dog extends TailWagger { ...
          -------
</code></pre>
<p>If you paste the <code>TailWagger</code> trait and <code>Dog</code> class into the Scala REPL, you can test the code like this:</p>
<pre><code class="language-scala">scala&gt; val d = new Dog
d: Dog = Dog@234e9716

scala&gt; d.startTail
tail is wagging

scala&gt; d.stopTail
tail is stopped
</code></pre>
<p>This demonstrates how you implement a single Scala trait with a class that extends the trait.</p>
<h2 id="extending-multiple-traits"><a class="header" href="#extending-multiple-traits">Extending multiple traits</a></h2>
<p>Scala lets you create very modular code with traits. For example, you can break down the attributes of animals into small, logical, modular units:</p>
<pre><code class="language-scala">trait Speaker {
    def speak(): String
}

trait TailWagger {
    def startTail(): Unit
    def stopTail(): Unit
}

trait Runner {
    def startRunning(): Unit
    def stopRunning(): Unit
}
</code></pre>
<p>Once you have those small pieces, you can create a <code>Dog</code> class by extending all of them, and implementing the necessary methods:</p>
<pre><code class="language-scala">class Dog extends Speaker with TailWagger with Runner {

    // Speaker
    def speak(): String = &quot;Woof!&quot;

    // TailWagger
    def startTail(): Unit = println(&quot;tail is wagging&quot;)
    def stopTail(): Unit = println(&quot;tail is stopped&quot;)

    // Runner
    def startRunning(): Unit = println(&quot;I'm running&quot;)
    def stopRunning(): Unit = println(&quot;Stopped running&quot;)

}
</code></pre>
<p>Notice how <code>extends</code> and <code>with</code> are used to create a class from multiple traits:</p>
<pre><code class="language-scala">class Dog extends Speaker with TailWagger with Runner {
          -------         ----            ----
</code></pre>
<p>Key points of this code:</p>
<ul>
<li>Use <code>extends</code> to extend the first trait</li>
<li>Use <code>with</code> to extend subsequent traits</li>
</ul>
<p>From what you’ve seen so far, Scala traits work just like Java interfaces. But there’s more ...</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Using Scala Traits Like Abstract Classes
description: This page shows how to use Scala traits just like abstract classes in Java, with examples of concrete and abstract methods.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 26
outof: 54
previous-page: traits-interfaces
next-page: abstract-classes</h2>
<p>In the previous lesson we showed how to use Scala traits like the original Java interface, but they have much more functionality than that. You can also add real, working methods to them and use them like abstract classes, or more accurately, as <em>mixins</em>.</p>
<h2 id="a-first-example"><a class="header" href="#a-first-example">A first example</a></h2>
<p>To demonstrate this, here’s a Scala trait that has a concrete method named <code>speak</code>, and an abstract method named <code>comeToMaster</code>:</p>
<pre><code class="language-scala">trait Pet {
    def speak = println(&quot;Yo&quot;)     // concrete implementation of a speak method
    def comeToMaster(): Unit      // abstract
}
</code></pre>
<p>When a class extends a trait, each abstract method must be implemented, so here’s a class that extends <code>Pet</code> and defines <code>comeToMaster</code>:</p>
<pre><code class="language-scala">class Dog(name: String) extends Pet {
    def comeToMaster(): Unit = println(&quot;Woo-hoo, I'm coming!&quot;)
}
</code></pre>
<p>Unless you want to override <code>speak</code>, there’s no need to redefine it, so this is a perfectly complete Scala class. Now you can create a new <code>Dog</code> like this:</p>
<pre><code class="language-scala">val d = new Dog(&quot;Zeus&quot;)
</code></pre>
<p>Then you can call <code>speak</code> and <code>comeToMaster</code>. This is what it looks like in the REPL:</p>
<pre><code class="language-scala">scala&gt; val d = new Dog(&quot;Zeus&quot;)
d: Dog = Dog@4136cb25

scala&gt; d.speak
Yo

scala&gt; d.comeToMaster
Woo-hoo, I'm coming!
</code></pre>
<h2 id="overriding-an-implemented-method"><a class="header" href="#overriding-an-implemented-method">Overriding an implemented method</a></h2>
<p>A class can also override a method that’s defined in a trait. Here’s an example:</p>
<pre><code class="language-scala">class Cat extends Pet {
    // override 'speak'
    override def speak(): Unit = println(&quot;meow&quot;)
    def comeToMaster(): Unit = println(&quot;That's not gonna happen.&quot;)
}
</code></pre>
<p>The REPL shows how this works:</p>
<pre><code class="language-scala">scala&gt; val c = new Cat
c: Cat = Cat@1953f27f

scala&gt; c.speak
meow

scala&gt; c.comeToMaster
That's not gonna happen.
</code></pre>
<h2 id="mixing-in-multiple-traits-that-have-behaviors"><a class="header" href="#mixing-in-multiple-traits-that-have-behaviors">Mixing in multiple traits that have behaviors</a></h2>
<p>A great thing about Scala traits is that you can mix multiple traits that have behaviors into classes. For example, here’s a combination of traits, one of which defines an abstract method, and the others that define concrete method implementations:</p>
<pre><code class="language-scala">trait Speaker {
    def speak(): String   //abstract
}

trait TailWagger {
    def startTail(): Unit = println(&quot;tail is wagging&quot;)
    def stopTail(): Unit = println(&quot;tail is stopped&quot;)
}

trait Runner {
    def startRunning(): Unit = println(&quot;I'm running&quot;)
    def stopRunning(): Unit = println(&quot;Stopped running&quot;)
}
</code></pre>
<p>Now you can create a <code>Dog</code> class that extends all of those traits while providing behavior for the <code>speak</code> method:</p>
<pre><code class="language-scala">class Dog(name: String) extends Speaker with TailWagger with Runner {
    def speak(): String = &quot;Woof!&quot;
}
</code></pre>
<p>And here’s a <code>Cat</code> class:</p>
<pre><code class="language-scala">class Cat extends Speaker with TailWagger with Runner {
    def speak(): String = &quot;Meow&quot;
    override def startRunning(): Unit = println(&quot;Yeah ... I don't run&quot;)
    override def stopRunning(): Unit = println(&quot;No need to stop&quot;)
}
</code></pre>
<p>The REPL shows that this all works like you’d expect it to work. First, a <code>Dog</code>:</p>
<pre><code class="language-scala">scala&gt; d.speak
res0: String = Woof!

scala&gt; d.startRunning
I'm running

scala&gt; d.startTail
tail is wagging
</code></pre>
<p>Then a <code>Cat</code>:</p>
<pre><code class="language-scala">scala&gt; val c = new Cat
c: Cat = Cat@1b252afa

scala&gt; c.speak
res1: String = Meow

scala&gt; c.startRunning
Yeah ... I don't run

scala&gt; c.startTail
tail is wagging
</code></pre>
<h2 id="mixing-traits-in-on-the-fly"><a class="header" href="#mixing-traits-in-on-the-fly">Mixing traits in on the fly</a></h2>
<p>As a last note, a very interesting thing you can do with traits that have concrete methods is mix them into classes on the fly. For example, given these traits:</p>
<pre><code class="language-scala">trait TailWagger {
    def startTail(): Unit = println(&quot;tail is wagging&quot;)
    def stopTail(): Unit = println(&quot;tail is stopped&quot;)
}

trait Runner {
    def startRunning(): Unit = println(&quot;I'm running&quot;)
    def stopRunning(): Unit = println(&quot;Stopped running&quot;)
}
</code></pre>
<p>and this <code>Dog</code> class:</p>
<pre><code class="language-scala">class Dog(name: String)
</code></pre>
<p>you can create a <code>Dog</code> instance that mixes in those traits when you create a <code>Dog</code> instance:</p>
<pre><code class="language-scala">val d = new Dog(&quot;Fido&quot;) with TailWagger with Runner
                        ---------------------------
</code></pre>
<p>Once again the REPL shows that this works:</p>
<pre><code class="language-scala">scala&gt; val d = new Dog(&quot;Fido&quot;) with TailWagger with Runner 
d: Dog with TailWagger with Runner = $anon$1@50c8d274

scala&gt; d.startTail
tail is wagging

scala&gt; d.startRunning
I'm running
</code></pre>
<p>This example works because all of the methods in the <code>TailWagger</code> and <code>Runner</code> traits are defined (they’re not abstract).</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Abstract Classes
description: This page shows how to use abstract classes, including when and why you should use abstract classes.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 27
outof: 54
previous-page: traits-abstract-mixins
next-page: collections-101</h2>
<p>Scala also has a concept of an abstract class that is similar to Java’s abstract class. But because traits are so powerful, you rarely need to use an abstract class. In fact, you only need to use an abstract class when:</p>
<ul>
<li>You want to create a base class that requires constructor arguments</li>
<li>Your Scala code will be called from Java code</li>
</ul>
<h2 id="scala-traits-dont-allow-constructor-parameters"><a class="header" href="#scala-traits-dont-allow-constructor-parameters">Scala traits don’t allow constructor parameters</a></h2>
<p>Regarding the first reason, Scala traits don’t allow constructor parameters:</p>
<pre><code class="language-scala">// this won’t compile
trait Animal(name: String)
</code></pre>
<p>Therefore, you need to use an abstract class whenever a base behavior must have constructor parameters:</p>
<pre><code class="language-scala">abstract class Animal(name: String)
</code></pre>
<p>However, be aware that a class can extend only one abstract class.</p>
<h2 id="when-scala-code-will-be-called-from-java-code"><a class="header" href="#when-scala-code-will-be-called-from-java-code">When Scala code will be called from Java code</a></h2>
<p>Regarding the second point — the second time when you’ll need to use an abstract class — because Java doesn’t know anything about Scala traits, if you want to call your Scala code from Java code, you’ll need to use an abstract class rather than a trait.</p>
<h2 id="abstract-class-syntax"><a class="header" href="#abstract-class-syntax">Abstract class syntax</a></h2>
<p>The abstract class syntax is similar to the trait syntax. For example, here’s an abstract class named <code>Pet</code> that’s similar to the <code>Pet</code> trait we defined in the previous lesson:</p>
<pre><code class="language-scala">abstract class Pet (name: String) {
    def speak(): Unit = println(&quot;Yo&quot;)   // concrete implementation
    def comeToMaster(): Unit            // abstract method
}
</code></pre>
<p>Given that abstract <code>Pet</code> class, you can define a <code>Dog</code> class like this:</p>
<pre><code class="language-scala">class Dog(name: String) extends Pet(name) {
    override def speak() = println(&quot;Woof&quot;)
    def comeToMaster() = println(&quot;Here I come!&quot;)
}
</code></pre>
<p>The REPL shows that this all works as advertised:</p>
<pre><code class="language-scala">scala&gt; val d = new Dog(&quot;Rover&quot;)
d: Dog = Dog@51f1fe1c

scala&gt; d.speak
Woof

scala&gt; d.comeToMaster
Here I come!
</code></pre>
<h3 id="notice-how-name-was-passed-along"><a class="header" href="#notice-how-name-was-passed-along">Notice how <code>name</code> was passed along</a></h3>
<p>All of that code is similar to Java, so we won’t explain it in detail. One thing to notice is how the <code>name</code> constructor parameter is passed from the <code>Dog</code> class constructor to the <code>Pet</code> constructor:</p>
<pre><code class="language-scala">class Dog(name: String) extends Pet(name) {
</code></pre>
<p>Remember that <code>Pet</code> is declared to take <code>name</code> as a constructor parameter:</p>
<pre><code class="language-scala">abstract class Pet (name: String) { ...
</code></pre>
<p>Therefore, this example shows how to pass the constructor parameter from the <code>Dog</code> class to the <code>Pet</code> abstract class. You can verify that this works with this code:</p>
<pre><code class="language-scala">abstract class Pet (name: String) {
    def speak: Unit = println(s&quot;My name is $name&quot;)
}

class Dog(name: String) extends Pet(name)

val d = new Dog(&quot;Fido&quot;)
d.speak
</code></pre>
<p>We encourage you to copy and paste that code into the REPL to be sure that it works as expected, and then experiment with it as desired.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: Scala Collections
description: This page provides an introduction to the Scala collections classes, including Vector, List, ArrayBuffer, Map, Set, and more.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 28
outof: 54
previous-page: abstract-classes
next-page: arraybuffer-examples</h2>
<p>If you’re coming to Scala from Java, the best thing you can do is forget about the Java collections classes and use the Scala collections classes as they’re intended to be used. As one author of this book has said, “Speaking from personal experience, when I first started working with Scala I tried to use Java collections classes in my Scala code, and all that did was slow down my progress.”</p>
<h2 id="the-main-scala-collections-classes"><a class="header" href="#the-main-scala-collections-classes">The main Scala collections classes</a></h2>
<p>The main Scala collections classes you’ll use on a regular basis are:</p>
<table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ArrayBuffer</code></td><td>an indexed, mutable sequence</td></tr>
<tr><td><code>List</code></td><td>a linear (linked list), immutable sequence</td></tr>
<tr><td><code>Vector</code></td><td>an indexed, immutable sequence</td></tr>
<tr><td><code>Map</code></td><td>the base <code>Map</code> (key/value pairs) class</td></tr>
<tr><td><code>Set</code></td><td>the base <code>Set</code> class</td></tr>
</tbody></table>
<p><code>Map</code> and <code>Set</code> come in both mutable and immutable versions.</p>
<p>We’ll demonstrate the basics of these classes in the following lessons.</p>
<blockquote>
<p>In the following lessons on Scala collections classes, whenever we use the word <em>immutable</em>, it’s safe to assume that the class is intended for use in a <em>functional programming</em> (FP) style. With these classes you don’t modify the collection; you apply functional methods to the collection to create a new result. You’ll see what this means in the examples that follow.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: The ArrayBuffer Class
description: This page provides examples of how to use the Scala ArrayBuffer class, including adding and removing elements.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 29
outof: 54
previous-page: collections-101
next-page: list-class</h2>
<p>If you’re an OOP developer coming to Scala from Java, the <code>ArrayBuffer</code> class will probably be most comfortable for you, so we’ll demonstrate it first. It’s a <em>mutable</em> sequence, so you can use its methods to modify its contents, and those methods are similar to methods on Java sequences.</p>
<p>To use an <code>ArrayBuffer</code> you must first import it:</p>
<pre><code class="language-scala">import scala.collection.mutable.ArrayBuffer
</code></pre>
<p>After it’s imported into the local scope, you create an empty <code>ArrayBuffer</code> like this:</p>
<pre><code class="language-scala">val ints = ArrayBuffer[Int]()
val names = ArrayBuffer[String]()
</code></pre>
<p>Once you have an <code>ArrayBuffer</code> you add elements to it in a variety of ways:</p>
<pre><code class="language-scala">val ints = ArrayBuffer[Int]()
ints += 1
ints += 2
</code></pre>
<p>The REPL shows how <code>+=</code> works:</p>
<pre><code class="language-scala">scala&gt; ints += 1
res0: ints.type = ArrayBuffer(1)

scala&gt; ints += 2
res1: ints.type = ArrayBuffer(1, 2)
</code></pre>
<p>That’s just one way to create an <code>ArrayBuffer</code> and add elements to it. You can also create an <code>ArrayBuffer</code> with initial elements like this:</p>
<pre><code class="language-scala">val nums = ArrayBuffer(1, 2, 3)
</code></pre>
<p>Here are a few ways you can add more elements to this <code>ArrayBuffer</code>:</p>
<pre><code class="language-scala">// add one element
nums += 4

// add multiple elements
nums += 5 += 6

// add multiple elements from another collection
nums ++= List(7, 8, 9)
</code></pre>
<p>You remove elements from an <code>ArrayBuffer</code> with the <code>-=</code> and <code>--=</code> methods:</p>
<pre><code class="language-scala">// remove one element
nums -= 9

// remove multiple elements
nums -= 7 -= 8

// remove multiple elements using another collection
nums --= Array(5, 6)
</code></pre>
<p>Here’s what all of those examples look like in the REPL:</p>
<pre><code class="language-scala">scala&gt; import scala.collection.mutable.ArrayBuffer

scala&gt; val nums = ArrayBuffer(1, 2, 3)
val nums: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3)

scala&gt; nums += 4
val res0: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4)

scala&gt; nums += 5 += 6
val res1: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6)

scala&gt; nums ++= List(7, 8, 9)
val res2: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8, 9)

scala&gt; nums -= 9
val res3: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8)

scala&gt; nums -= 7 -= 8
val res4: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6)

scala&gt; nums --= Array(5, 6)
val res5: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4)
</code></pre>
<h2 id="more-ways-to-work-with-arraybuffer"><a class="header" href="#more-ways-to-work-with-arraybuffer">More ways to work with <code>ArrayBuffer</code></a></h2>
<p>As a brief overview, here are several methods you can use with an <code>ArrayBuffer</code>:</p>
<pre><code class="language-scala">val a = ArrayBuffer(1, 2, 3)         // ArrayBuffer(1, 2, 3)
a.append(4)                          // ArrayBuffer(1, 2, 3, 4)
a.append(5, 6)                       // ArrayBuffer(1, 2, 3, 4, 5, 6)
a.appendAll(Seq(7,8))                // ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8)
a.clear                              // ArrayBuffer()

val a = ArrayBuffer(9, 10)           // ArrayBuffer(9, 10)
a.insert(0, 8)                       // ArrayBuffer(8, 9, 10)
a.insertAll(0, Vector(4, 5, 6, 7))   // ArrayBuffer(4, 5, 6, 7, 8, 9, 10)
a.prepend(3)                         // ArrayBuffer(3, 4, 5, 6, 7, 8, 9, 10)
a.prepend(1, 2)                      // ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
a.prependAll(Array(0))               // ArrayBuffer(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

val a = ArrayBuffer.range('a', 'h')  // ArrayBuffer(a, b, c, d, e, f, g)
a.remove(0)                          // ArrayBuffer(b, c, d, e, f, g)
a.remove(2, 3)                       // ArrayBuffer(b, c, g)

val a = ArrayBuffer.range('a', 'h')  // ArrayBuffer(a, b, c, d, e, f, g)
a.trimStart(2)                       // ArrayBuffer(c, d, e, f, g)
a.trimEnd(2)                         // ArrayBuffer(c, d, e)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: The List Class
description: This page provides examples of the Scala List class, including how to add and remove elements from a List.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 30
outof: 54
previous-page: arraybuffer-examples
next-page: vector-class</h2>
<p><a href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html">The List class</a> is a linear, immutable sequence. All this means is that it’s a linked-list that you can’t modify. Any time you want to add or remove <code>List</code> elements, you create a new <code>List</code> from an existing <code>List</code>.</p>
<h2 id="creating-lists"><a class="header" href="#creating-lists">Creating Lists</a></h2>
<p>This is how you create an initial <code>List</code>:</p>
<pre><code class="language-scala">val ints = List(1, 2, 3)
val names = List(&quot;Joel&quot;, &quot;Chris&quot;, &quot;Ed&quot;)
</code></pre>
<p>You can also declare the <code>List</code>’s type, if you prefer, though it generally isn’t necessary:</p>
<pre><code class="language-scala">val ints: List[Int] = List(1, 2, 3)
val names: List[String] = List(&quot;Joel&quot;, &quot;Chris&quot;, &quot;Ed&quot;)
</code></pre>
<h2 id="adding-elements-to-a-list"><a class="header" href="#adding-elements-to-a-list">Adding elements to a List</a></h2>
<p>Because <code>List</code> is immutable, you can’t add new elements to it. Instead you create a new list by prepending or appending elements to an existing <code>List</code>. For instance, given this <code>List</code>:</p>
<pre><code class="language-scala">val a = List(1,2,3)
</code></pre>
<p>You <em>prepend</em> elements to a <code>List</code> like this:</p>
<pre><code class="language-scala">val b = 0 +: a
</code></pre>
<p>and this:</p>
<pre><code class="language-scala">val b = List(-1, 0) ++: a
</code></pre>
<p>The REPL shows how this works:</p>
<pre><code class="language-scala">scala&gt; val b = 0 +: a
b: List[Int] = List(0, 1, 2, 3)

scala&gt; val b = List(-1, 0) ++: a
b: List[Int] = List(-1, 0, 1, 2, 3)
</code></pre>
<p>You can also <em>append</em> elements to a <code>List</code>, but because <code>List</code> is a singly-linked list, you should really only prepend elements to it; appending elements to it is a relatively slow operation, especially when you work with large sequences.</p>
<blockquote>
<p>Tip: If you want to prepend and append elements to an immutable sequence, use <code>Vector</code> instead.</p>
</blockquote>
<p>Because <code>List</code> is a linked-list class, you shouldn’t try to access the elements of large lists by their index value. For instance, if you have a <code>List</code> with one million elements in it, accessing an element like <code>myList(999999)</code> will take a long time. If you want to access elements like this, use a <code>Vector</code> or <code>ArrayBuffer</code> instead.</p>
<h2 id="how-to-remember-the-method-names"><a class="header" href="#how-to-remember-the-method-names">How to remember the method names</a></h2>
<p>These days, IDEs help us out tremendously, but one way to remember those method names is to think that the <code>:</code> character represents the side that the sequence is on, so when you use <code>+:</code> you know that the list needs to be on the right, like this:</p>
<pre><code class="language-scala">0 +: a
</code></pre>
<p>Similarly, when you use <code>:+</code> you know the list needs to be on the left:</p>
<pre><code class="language-scala">a :+ 4
</code></pre>
<p>There are more technical ways to think about this, this can be a simple way to remember the method names.</p>
<p>One good thing about these method names: they’re consistent. The same method names are used with other immutable sequence classes, such as <code>Seq</code> and <code>Vector</code>.</p>
<h2 id="how-to-loop-over-lists"><a class="header" href="#how-to-loop-over-lists">How to loop over lists</a></h2>
<p>We showed how to loop over lists earlier in this book, but it’s worth showing the syntax again. Given a <code>List</code> like this:</p>
<pre><code class="language-scala">val names = List(&quot;Joel&quot;, &quot;Chris&quot;, &quot;Ed&quot;)
</code></pre>
<p>you can print each string like this:</p>
<pre><code class="language-scala">for (name &lt;- names) println(name)
</code></pre>
<p>This is what it looks like in the REPL:</p>
<pre><code class="language-scala">scala&gt; for (name &lt;- names) println(name)
Joel
Chris
Ed
</code></pre>
<p>A great thing about this approach is that it works with all sequence classes, including <code>ArrayBuffer</code>, <code>List</code>, <code>Seq</code>, <code>Vector</code>, etc.</p>
<h2 id="a-little-bit-of-history"><a class="header" href="#a-little-bit-of-history">A little bit of history</a></h2>
<p>If you’re interested in a little bit of history, the <code>List</code> class is very similar to the <code>List</code> class from the Lisp programming language. Indeed, in addition to creating a <code>List</code> like this:</p>
<pre><code class="language-scala">val ints = List(1, 2, 3)
</code></pre>
<p>you can also create the exact same list this way:</p>
<pre><code class="language-scala">val list = 1 :: 2 :: 3 :: Nil
</code></pre>
<p>The REPL shows how this works:</p>
<pre><code class="language-scala">scala&gt; val list = 1 :: 2 :: 3 :: Nil
list: List[Int] = List(1, 2, 3)
</code></pre>
<p>This works because a <code>List</code> is a singly-linked list that ends with the <code>Nil</code> element.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: The Vector Class
description: This page provides examples of the Scala 'Vector' class, including how to add and remove elements from a Vector.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 31
outof: 54
previous-page: list-class
next-page: map-class</h2>
<p><a href="https://www.scala-lang.org/api/current/scala/collection/immutable/Vector.html">The Vector class</a> is an indexed, immutable sequence. The “indexed” part of the description means that you can access <code>Vector</code> elements very rapidly by their index value, such as accessing <code>listOfPeople(999999)</code>.</p>
<p>In general, except for the difference that <code>Vector</code> is indexed and <code>List</code> is not, the two classes work the same, so we’ll run through these examples quickly.</p>
<p>Here are a few ways you can create a <code>Vector</code>:</p>
<pre><code class="language-scala">val nums = Vector(1, 2, 3, 4, 5)

val strings = Vector(&quot;one&quot;, &quot;two&quot;)

val peeps = Vector(
    Person(&quot;Bert&quot;),
    Person(&quot;Ernie&quot;),
    Person(&quot;Grover&quot;)
)
</code></pre>
<p>Because <code>Vector</code> is immutable, you can’t add new elements to it. Instead you create a new sequence by appending or prepending elements to an existing <code>Vector</code>. For instance, given this <code>Vector</code>:</p>
<pre><code class="language-scala">val a = Vector(1,2,3)
</code></pre>
<p>you <em>append</em> elements like this:</p>
<pre><code class="language-scala">val b = a :+ 4
</code></pre>
<p>and this:</p>
<pre><code class="language-scala">val b = a ++ Vector(4, 5)
</code></pre>
<p>The REPL shows how this works:</p>
<pre><code class="language-scala">scala&gt; val a = Vector(1,2,3)
a: Vector[Int] = Vector(1, 2, 3)

scala&gt; val b = a :+ 4
b: Vector[Int] = Vector(1, 2, 3, 4)

scala&gt; val b = a ++ Vector(4, 5)
b: Vector[Int] = Vector(1, 2, 3, 4, 5)
</code></pre>
<p>You can also <em>prepend</em> elements like this:</p>
<pre><code class="language-scala">val b = 0 +: a
</code></pre>
<p>and this:</p>
<pre><code class="language-scala">val b = Vector(-1, 0) ++: a
</code></pre>
<p>Once again the REPL shows how this works:</p>
<pre><code class="language-scala">scala&gt; val b = 0 +: a
b: Vector[Int] = Vector(0, 1, 2, 3)

scala&gt; val b = Vector(-1, 0) ++: a
b: Vector[Int] = Vector(-1, 0, 1, 2, 3)
</code></pre>
<p>Because <code>Vector</code> is not a linked-list (like <code>List</code>), you can prepend and append elements to it, and the speed of both approaches should be similar.</p>
<p>Finally, you loop over elements in a <code>Vector</code> just like you do with an <code>ArrayBuffer</code> or <code>List</code>:</p>
<pre><code class="language-scala">scala&gt; val names = Vector(&quot;Joel&quot;, &quot;Chris&quot;, &quot;Ed&quot;)
val names: Vector[String] = Vector(Joel, Chris, Ed)

scala&gt; for (name &lt;- names) println(name)
Joel
Chris
Ed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: The Map Class
description: This page provides examples of the Scala 'Map' class, including how to add and remove elements from a Map, and iterate over Map elements.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 32
outof: 54
previous-page: vector-class
next-page: set-class</h2>
<p>The <a href="%7B%7Bsite.baseurl%7D%7D/overviews/collections-2.13/maps.html">Map class documentation</a> describes a <code>Map</code> as an iterable sequence that consists of pairs of keys and values. A simple <code>Map</code> looks like this:</p>
<pre><code class="language-scala">val states = Map(
    &quot;AK&quot; -&gt; &quot;Alaska&quot;,
    &quot;IL&quot; -&gt; &quot;Illinois&quot;,
    &quot;KY&quot; -&gt; &quot;Kentucky&quot;
)
</code></pre>
<p>Scala has both mutable and immutable <code>Map</code> classes. In this lesson we’ll show how to use the <em>mutable</em> class.</p>
<h2 id="creating-a-mutable-map"><a class="header" href="#creating-a-mutable-map">Creating a mutable Map</a></h2>
<p>To use the mutable <code>Map</code> class, first import it:</p>
<pre><code class="language-scala">import scala.collection.mutable.Map
</code></pre>
<p>Then you can create a <code>Map</code> like this:</p>
<pre><code class="language-scala">val states = collection.mutable.Map(&quot;AK&quot; -&gt; &quot;Alaska&quot;)
</code></pre>
<h2 id="adding-elements-to-a-map"><a class="header" href="#adding-elements-to-a-map">Adding elements to a Map</a></h2>
<p>Now you can add a single element to the <code>Map</code> with <code>+=</code>, like this:</p>
<pre><code class="language-scala">states += (&quot;AL&quot; -&gt; &quot;Alabama&quot;)
</code></pre>
<p>You also add multiple elements using <code>+=</code>:</p>
<pre><code class="language-scala">states += (&quot;AR&quot; -&gt; &quot;Arkansas&quot;, &quot;AZ&quot; -&gt; &quot;Arizona&quot;)
</code></pre>
<p>You can add elements from another <code>Map</code> using <code>++=</code>:</p>
<pre><code class="language-scala">states ++= Map(&quot;CA&quot; -&gt; &quot;California&quot;, &quot;CO&quot; -&gt; &quot;Colorado&quot;)
</code></pre>
<p>The REPL shows how these examples work:</p>
<pre><code class="language-scala">scala&gt; val states = collection.mutable.Map(&quot;AK&quot; -&gt; &quot;Alaska&quot;)
states: scala.collection.mutable.Map[String,String] = Map(AK -&gt; Alaska)

scala&gt; states += (&quot;AL&quot; -&gt; &quot;Alabama&quot;)
res0: states.type = Map(AL -&gt; Alabama, AK -&gt; Alaska)

scala&gt; states += (&quot;AR&quot; -&gt; &quot;Arkansas&quot;, &quot;AZ&quot; -&gt; &quot;Arizona&quot;)
res1: states.type = Map(AZ -&gt; Arizona, AL -&gt; Alabama, AR -&gt; Arkansas, AK -&gt; Alaska)

scala&gt; states ++= Map(&quot;CA&quot; -&gt; &quot;California&quot;, &quot;CO&quot; -&gt; &quot;Colorado&quot;)
res2: states.type = Map(CO -&gt; Colorado, AZ -&gt; Arizona, AL -&gt; Alabama, CA -&gt; California, AR -&gt; Arkansas, AK -&gt; Alaska)
</code></pre>
<h2 id="removing-elements-from-a-map"><a class="header" href="#removing-elements-from-a-map">Removing elements from a Map</a></h2>
<p>You remove elements from a <code>Map</code> using <code>-=</code> and <code>--=</code> and specifying the key values, as shown in the following examples:</p>
<pre><code class="language-scala">states -= &quot;AR&quot;
states -= (&quot;AL&quot;, &quot;AZ&quot;)
states --= List(&quot;AL&quot;, &quot;AZ&quot;)
</code></pre>
<p>The REPL shows how these examples work:</p>
<pre><code class="language-scala">scala&gt; states -= &quot;AR&quot;
res3: states.type = Map(CO -&gt; Colorado, AZ -&gt; Arizona, AL -&gt; Alabama, CA -&gt; California, AK -&gt; Alaska)

scala&gt; states -= (&quot;AL&quot;, &quot;AZ&quot;)
res4: states.type = Map(CO -&gt; Colorado, CA -&gt; California, AK -&gt; Alaska)

scala&gt; states --= List(&quot;AL&quot;, &quot;AZ&quot;)
res5: states.type = Map(CO -&gt; Colorado, CA -&gt; California, AK -&gt; Alaska)
</code></pre>
<h2 id="updating-map-elements"><a class="header" href="#updating-map-elements">Updating Map elements</a></h2>
<p>You update <code>Map</code> elements by reassigning their key to a new value:</p>
<pre><code class="language-scala">states(&quot;AK&quot;) = &quot;Alaska, A Really Big State&quot;
</code></pre>
<p>The REPL shows the current <code>Map</code> state:</p>
<pre><code class="language-scala">scala&gt; states(&quot;AK&quot;) = &quot;Alaska, A Really Big State&quot;

scala&gt; states
res6: scala.collection.mutable.Map[String,String] = Map(CO -&gt; Colorado, CA -&gt; California, AK -&gt; Alaska, A Really Big State)
</code></pre>
<h2 id="traversing-a-map"><a class="header" href="#traversing-a-map">Traversing a Map</a></h2>
<p>There are several different ways to iterate over the elements in a map. Given a sample map:</p>
<pre><code class="language-scala">val ratings = Map(
    &quot;Lady in the Water&quot;-&gt; 3.0, 
    &quot;Snakes on a Plane&quot;-&gt; 4.0,
    &quot;You, Me and Dupree&quot;-&gt; 3.5
)
</code></pre>
<p>a nice way to loop over all of the map elements is with this <code>for</code> loop syntax:</p>
<pre><code class="language-scala">for ((k,v) &lt;- ratings) println(s&quot;key: $k, value: $v&quot;)
</code></pre>
<p>Using a <code>match</code> expression with the <code>foreach</code> method is also very readable:</p>
<pre><code class="language-scala">ratings.foreach {
    case(movie, rating) =&gt; println(s&quot;key: $movie, value: $rating&quot;)
}
</code></pre>
<blockquote>
<p>The <code>ratings</code> map data in this example comes from the old-but-good book, <em>Programming Collective Intelligence</em>.</p>
</blockquote>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<p>There are other ways to work with Scala Maps, and a nice collection of Map classes for different needs. See the <a href="%7B%7Bsite.baseurl%7D%7D/overviews/collections-2.13/maps.html">Map class documentation</a> for more information and examples.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: The Set Class
description: This page provides examples of the Scala 'Set' class, including how to add and remove elements from a Set, and iterate over Set elements.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 33
outof: 54
previous-page: map-class
next-page: anonymous-functions</h2>
<p>The <a href="%7B%7Bsite.baseurl%7D%7D/overviews/collections-2.13/sets.html">Scala Set class</a> is an iterable collection with no duplicate elements.</p>
<p>Scala has both mutable and immutable <code>Set</code> classes. In this lesson we’ll show how to use the <em>mutable</em> class.</p>
<h2 id="adding-elements-to-a-set"><a class="header" href="#adding-elements-to-a-set">Adding elements to a Set</a></h2>
<p>To use a mutable <code>Set</code>, first import it:</p>
<pre><code class="language-scala">val set = scala.collection.mutable.Set[Int]()
</code></pre>
<p>You add elements to a mutable <code>Set</code> with the <code>+=</code>, <code>++=</code>, and <code>add</code> methods. Here are a few examples:</p>
<pre><code class="language-scala">set += 1
set += 2 += 3
set ++= Vector(4, 5)
</code></pre>
<p>The REPL shows how these examples work:</p>
<pre><code class="language-scala">scala&gt; val set = scala.collection.mutable.Set[Int]()
val set: scala.collection.mutable.Set[Int] = Set()

scala&gt; set += 1
val res0: scala.collection.mutable.Set[Int] = Set(1)

scala&gt; set += 2 += 3
val res1: scala.collection.mutable.Set[Int] = Set(1, 2, 3)

scala&gt; set ++= Vector(4, 5)
val res2: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 3, 4)
</code></pre>
<p>Notice that if you try to add a value to a set that’s already in it, the attempt is quietly ignored:</p>
<pre><code class="language-scala">scala&gt; set += 2
val res3: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 3, 4)
</code></pre>
<p><code>Set</code> also has an <code>add</code> method that returns <code>true</code> if an element is added to a set, and <code>false</code> if it wasn’t added. The REPL shows how it works:</p>
<pre><code class="language-scala">scala&gt; set.add(6)
res4: Boolean = true

scala&gt; set.add(5)
res5: Boolean = false
</code></pre>
<h2 id="deleting-elements-from-a-set"><a class="header" href="#deleting-elements-from-a-set">Deleting elements from a Set</a></h2>
<p>You remove elements from a set using the <code>-=</code> and <code>--=</code> methods, as shown in the following examples:</p>
<pre><code class="language-scala">scala&gt; val set = scala.collection.mutable.Set(1, 2, 3, 4, 5)
set: scala.collection.mutable.Set[Int] = Set(2, 1, 4, 3, 5)

// one element
scala&gt; set -= 1
res0: scala.collection.mutable.Set[Int] = Set(2, 4, 3, 5)

// two or more elements (-= has a varargs field)
scala&gt; set -= (2, 3)
res1: scala.collection.mutable.Set[Int] = Set(4, 5)

// multiple elements defined in another sequence
scala&gt; set --= Array(4,5)
res2: scala.collection.mutable.Set[Int] = Set()
</code></pre>
<p>There are more methods for working with sets, including <code>clear</code> and <code>remove</code>, as shown in these examples:</p>
<pre><code class="language-scala">scala&gt; val set = scala.collection.mutable.Set(1, 2, 3, 4, 5)
set: scala.collection.mutable.Set[Int] = Set(2, 1, 4, 3, 5)

// clear
scala&gt; set.clear()

scala&gt; set
res0: scala.collection.mutable.Set[Int] = Set()

// remove
scala&gt; val set = scala.collection.mutable.Set(1, 2, 3, 4, 5)
set: scala.collection.mutable.Set[Int] = Set(2, 1, 4, 3, 5)

scala&gt; set.remove(2)
res1: Boolean = true

scala&gt; set
res2: scala.collection.mutable.Set[Int] = Set(1, 4, 3, 5)

scala&gt; set.remove(40)
res3: Boolean = false
</code></pre>
<h2 id="more-sets"><a class="header" href="#more-sets">More Sets</a></h2>
<p>Scala has several more <code>Set</code> classes, including <code>SortedSet</code>, <code>LinkedHashSet</code>, and more. Please see the <a href="%7B%7Bsite.baseurl%7D%7D/overviews/collections-2.13/sets.html">Set class documentation</a> for more details on those classes.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Anonymous Functions
description: This page shows how to use anonymous functions in Scala, including examples with the List class 'map' and 'filter' functions.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 34
outof: 54
previous-page: set-class
next-page: collections-methods</h2>
<p>Earlier in this book you saw that you can create a list of integers like this:</p>
<pre><code class="language-scala">val ints = List(1,2,3)
</code></pre>
<p>When you want to create a larger list, you can also create them with the <code>List</code> class <code>range</code> method, like this:</p>
<pre><code class="language-scala">val ints = List.range(1, 10)
</code></pre>
<p>That code creates <code>ints</code> as a list of integers whose values range from 1 to 10. You can see the result in the REPL:</p>
<pre><code class="language-scala">scala&gt; val ints = List.range(1, 10)
x: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
</code></pre>
<p>In this lesson we’ll use lists like these to demonstrate a feature of functional programming known as <em>anonymous functions</em>. It will help to understand how these work before we demonstrate the most common Scala collections methods.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>An anonymous function is like a little mini-function. For example, given a list like this:</p>
<pre><code class="language-scala">val ints = List(1,2,3)
</code></pre>
<p>You can create a new list by doubling each element in <code>ints</code>, like this:</p>
<pre><code class="language-scala">val doubledInts = ints.map(_ * 2)
</code></pre>
<p>This is what that example looks like in the REPL:</p>
<pre><code class="language-scala">scala&gt; val doubledInts = ints.map(_ * 2)
doubledInts: List[Int] = List(2, 4, 6)
</code></pre>
<p>As that shows, <code>doubledInts</code> is now the list, <code>List(2, 4, 6)</code>. In this example, this code is an anonymous function:</p>
<pre><code class="language-scala">_ * 2
</code></pre>
<p>This is a shorthand way of saying, “Multiply an element by 2.” </p>
<p>Once you’re comfortable with Scala, this is a common way to write anonymous functions, but if you prefer, you can also write them using longer forms. Besides writing that code like this:</p>
<pre><code class="language-scala">val doubledInts = ints.map(_ * 2)
</code></pre>
<p>you can also write it like this:</p>
<pre><code class="language-scala">val doubledInts = ints.map((i: Int) =&gt; i * 2)
val doubledInts = ints.map(i =&gt; i * 2)
</code></pre>
<p>All three lines have exactly the same meaning: Double each element in <code>ints</code> to create a new list, <code>doubledInts</code>.</p>
<blockquote>
<p>The <code>_</code> character in Scala is something of a wildcard character. You’ll see it used in several different places. In this case it’s a shorthand way of saying, “An element from the list, <code>ints</code>.”</p>
</blockquote>
<p>Before going any further, it’s worth mentioning that this <code>map</code> example is the equivalent of this Java code:</p>
<pre><code class="language-java">List&lt;Integer&gt; ints = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));

// the `map` process
List&lt;Integer&gt; doubledInts = ints.stream()
                                .map(i -&gt; i * 2)
                                .collect(Collectors.toList());
</code></pre>
<p>The <code>map</code> example shown is also the same as this Scala code:</p>
<pre><code class="language-scala">val doubledInts = for (i &lt;- ints) yield i * 2
</code></pre>
<h2 id="anonymous-functions-with-the-filter-method"><a class="header" href="#anonymous-functions-with-the-filter-method">Anonymous functions with the <code>filter</code> method</a></h2>
<p>Another good way to show anonymous functions is with the <code>filter</code> method of the <code>List</code> class. Given this <code>List</code> again:</p>
<pre><code class="language-scala">val ints = List.range(1, 10)
</code></pre>
<p>This is how you create a new list of all integers whose value is greater than 5:</p>
<pre><code class="language-scala">val x = ints.filter(_ &gt; 5)
</code></pre>
<p>This is how you create a new list whose values are all less than 5:</p>
<pre><code class="language-scala">val x = ints.filter(_ &lt; 5)
</code></pre>
<p>And as a little more complicated example, this is how you create a new list that contains only even values, by using the modulus operator:</p>
<pre><code class="language-scala">val x = ints.filter(_ % 2 == 0)
</code></pre>
<p>If that’s a little confusing, remember that this example can also be written in these other ways:</p>
<pre><code class="language-scala">val x = ints.filter((i: Int) =&gt; i % 2 == 0)
val x = ints.filter(i =&gt; i % 2 == 0)
</code></pre>
<p>This is what the previous examples look like in the REPL:</p>
<pre><code class="language-scala">scala&gt; val x = ints.filter(_ &gt; 5)
x: List[Int] = List(6, 7, 8, 9)

scala&gt; val x = ints.filter(_ &lt; 5)
x: List[Int] = List(1, 2, 3, 4)

scala&gt; val x = ints.filter(_ % 2 == 0)
x: List[Int] = List(2, 4, 6, 8)
</code></pre>
<h2 id="key-points"><a class="header" href="#key-points">Key points</a></h2>
<p>The key points of this lesson are:</p>
<ul>
<li>You can write anonymous functions as little snippets of code</li>
<li>You can use them with methods on the <code>List</code> class like <code>map</code> and <code>filter</code></li>
<li>With these little snippets of code and powerful methods like those, you can create a lot of functionality with very little code</li>
</ul>
<p>The Scala collections classes contain many methods like <code>map</code> and <code>filter</code>, and they’re a powerful way to create very expressive code.</p>
<h2 id="bonus-digging-a-little-deeper"><a class="header" href="#bonus-digging-a-little-deeper">Bonus: Digging a little deeper</a></h2>
<p>You may be wondering how the <code>map</code> and <code>filter</code> examples work. The short answer is that when <code>map</code> is invoked on a list of integers — a <code>List[Int]</code> to be more precise — <code>map</code> expects to receive a function that transforms one <code>Int</code> value into another <code>Int</code> value. Because <code>map</code> expects a function (or method) that transforms one <code>Int</code> to another <code>Int</code>, this approach also works:</p>
<pre><code class="language-scala">val ints = List(1,2,3)
def double(i: Int): Int = i * 2   //a method that doubles an Int
val doubledInts = ints.map(double)
</code></pre>
<p>The last two lines of that example are the same as this:</p>
<pre><code class="language-scala">val doubledInts = ints.map(_ * 2)
</code></pre>
<p>Similarly, when called on a <code>List[Int]</code>, the <code>filter</code> method expects to receive a function that takes an <code>Int</code> and returns a <code>Boolean</code> value. Therefore, given a method that’s defined like this:</p>
<pre><code class="language-scala">def lessThanFive(i: Int): Boolean = if (i &lt; 5) true else false
</code></pre>
<p>or more concisely, like this:</p>
<pre><code class="language-scala">def lessThanFive(i: Int): Boolean = (i &lt; 5)
</code></pre>
<p>this <code>filter</code> example:</p>
<pre><code class="language-scala">val ints = List.range(1, 10)
val y = ints.filter(lessThanFive)
</code></pre>
<p>is the same as this example:</p>
<pre><code class="language-scala">val y = ints.filter(_ &lt; 5)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Common Sequence Methods
description: This page shows examples of the most common methods that are available on the Scala sequences (collections classes).
partof: scala_book
overview-name: Scala Book
discourse: true
num: 35
outof: 54
previous-page: anonymous-functions
next-page: collections-maps</h2>
<p>A great strength of the Scala collections classes is that they come with dozens of pre-built methods. The benefit of this is that you no longer need to write custom <code>for</code> loops every time you need to work on a collection. (If that’s not enough of a benefit, it also means that you no longer have to read custom <code>for</code> loops written by other developers.)</p>
<p>Because there are so many methods available to you, they won’t all be shown here. Instead, just some of the most commonly-used methods will be shown, including:</p>
<ul>
<li><code>map</code></li>
<li><code>filter</code></li>
<li><code>foreach</code></li>
<li><code>head</code></li>
<li><code>tail</code></li>
<li><code>take</code>, <code>takeWhile</code></li>
<li><code>drop</code>, <code>dropWhile</code></li>
<li><code>reduce</code></li>
</ul>
<p>The following methods will work on all of the collections “sequence” classes, including <code>Array</code>, <code>ArrayBuffer</code>, <code>List</code>, <code>Vector</code>, etc., but these examples will use a <code>List</code> unless otherwise specified.</p>
<h2 id="note-the-methods-dont-mutate-the-collection"><a class="header" href="#note-the-methods-dont-mutate-the-collection">Note: The methods don’t mutate the collection</a></h2>
<p>As a very important note, none of these methods mutate the collection that they’re called on. They all work in a functional style, so they return a new collection with the modified results.</p>
<h2 id="sample-lists"><a class="header" href="#sample-lists">Sample lists</a></h2>
<p>The following examples will use these lists:</p>
<pre><code class="language-scala">val nums = (1 to 10).toList
val names = List(&quot;joel&quot;, &quot;ed&quot;, &quot;chris&quot;, &quot;maurice&quot;)
</code></pre>
<p>This is what those lists look like in the REPL:</p>
<pre><code class="language-scala">scala&gt; val nums = (1 to 10).toList
nums: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala&gt; val names = List(&quot;joel&quot;, &quot;ed&quot;, &quot;chris&quot;, &quot;maurice&quot;)
names: List[String] = List(joel, ed, chris, maurice)
</code></pre>
<h2 id="map"><a class="header" href="#map"><code>map</code></a></h2>
<p>The <code>map</code> method steps through each element in the existing list, applying the algorithm you supply to each element, one at a time; it then returns a new list with all of the modified elements.</p>
<p>Here’s an example of the <code>map</code> method being applied to the <code>nums</code> list:</p>
<pre><code class="language-scala">scala&gt; val doubles = nums.map(_ * 2)
doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
</code></pre>
<p>As we showed in the lesson on anonymous functions, you can also write the anonymous function like this:</p>
<pre><code class="language-scala">scala&gt; val doubles = nums.map(i =&gt; i * 2)
doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
</code></pre>
<p>However, in this lesson we’ll always use the first, shorter form.</p>
<p>With that background, here’s an example of the <code>map</code> method being applied to the <code>nums</code> and <code>names</code> lists:</p>
<pre><code class="language-scala">scala&gt; val capNames = names.map(_.capitalize)
capNames: List[String] = List(Joel, Ed, Chris, Maurice)

scala&gt; val doubles = nums.map(_ * 2)
doubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)

scala&gt; val lessThanFive = nums.map(_ &lt; 5)
lessThanFive: List[Boolean] = List(true, true, true, true, false, false, false, false, false, false)
</code></pre>
<p>As that last example shows, it’s perfectly legal (and very common) to use map to return a list with a different type (<code>List[Boolean]</code>) from the original type (<code>List[Int]</code>).</p>
<h2 id="filter"><a class="header" href="#filter"><code>filter</code></a></h2>
<p>The <code>filter</code> method creates a new, filtered list from the given list. Here are a few examples:</p>
<pre><code class="language-scala">scala&gt; val lessThanFive = nums.filter(_ &lt; 5)
lessThanFive: List[Int] = List(1, 2, 3, 4)

scala&gt; val evens = nums.filter(_ % 2 == 0)
evens: List[Int] = List(2, 4, 6, 8, 10)

scala&gt; val shortNames = names.filter(_.length &lt;= 4)
shortNames: List[String] = List(joel, ed)
</code></pre>
<h2 id="foreach"><a class="header" href="#foreach"><code>foreach</code></a></h2>
<p>The <code>foreach</code> method is used to loop over all elements in a collection. As we mentioned in a previous lesson, <code>foreach</code> is used for side-effects, such as printing information. Here’s an example with the <code>names</code> list:</p>
<pre><code class="language-scala">scala&gt; names.foreach(println)
joel
ed
chris
maurice
</code></pre>
<p>The <code>nums</code> list is a little long, so you may not want to print out all of those elements. But a great thing about Scala’s approach is that you can chain methods together to solve problems like this. For example, this is one way to print the first three elements from <code>nums</code>:</p>
<pre><code class="language-scala">nums.filter(_ &lt; 4).foreach(println)
</code></pre>
<p>The REPL shows the result:</p>
<pre><code class="language-scala">scala&gt; nums.filter(_ &lt; 4).foreach(println)
1
2
3
</code></pre>
<h2 id="head"><a class="header" href="#head"><code>head</code></a></h2>
<p>The <code>head</code> method comes from Lisp and functional programming languages. It’s used to print the first element (the head element) of a list:</p>
<pre><code class="language-scala">scala&gt; nums.head
res0: Int = 1

scala&gt; names.head
res1: String = joel
</code></pre>
<p>Because a <code>String</code> is a sequence of characters, you can also treat it like a list. This is how <code>head</code> works on these strings:</p>
<pre><code class="language-scala">scala&gt; &quot;foo&quot;.head
res2: Char = f

scala&gt; &quot;bar&quot;.head
res3: Char = b
</code></pre>
<p><code>head</code> is a great method to work with, but as a word of caution it can also throw an exception when called on an empty collection:</p>
<pre><code class="language-scala">scala&gt; val emptyList = List[Int]()
val emptyList: List[Int] = List()

scala&gt; emptyList.head
java.util.NoSuchElementException: head of empty list
</code></pre>
<h2 id="tail"><a class="header" href="#tail"><code>tail</code></a></h2>
<p>The <code>tail</code> method also comes from Lisp and functional programming languages. It’s used to print every element in a list after the head element. A few examples:</p>
<pre><code class="language-scala">scala&gt; nums.tail
res0: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10)

scala&gt; names.tail
res1: List[String] = List(ed, chris, maurice)
</code></pre>
<p>Just like <code>head</code>, <code>tail</code> also works on strings:</p>
<pre><code class="language-scala">scala&gt; &quot;foo&quot;.tail
res2: String = oo

scala&gt; &quot;bar&quot;.tail
res3: String = ar
</code></pre>
<p>Note that like <code>head</code>, <code>tail</code> will also throw an exception when called on an empty collection:</p>
<pre><code class="language-scala">scala&gt; emptyList.tail
java.lang.UnsupportedOperationException: tail of empty list
</code></pre>
<h2 id="take-takewhile"><a class="header" href="#take-takewhile"><code>take</code>, <code>takeWhile</code></a></h2>
<p>The <code>take</code> and <code>takeWhile</code> methods give you a nice way of taking the elements out of a list that you want to create a new list. This is <code>take</code>:</p>
<pre><code class="language-scala">scala&gt; nums.take(1)
res0: List[Int] = List(1)

scala&gt; nums.take(2)
res1: List[Int] = List(1, 2)

scala&gt; names.take(1)
res2: List[String] = List(joel)

scala&gt; names.take(2)
res3: List[String] = List(joel, ed)
</code></pre>
<p>And this is <code>takeWhile</code>:</p>
<pre><code class="language-scala">scala&gt; nums.takeWhile(_ &lt; 5)
res4: List[Int] = List(1, 2, 3, 4)

scala&gt; names.takeWhile(_.length &lt; 5)
res5: List[String] = List(joel, ed)
</code></pre>
<h2 id="drop-dropwhile"><a class="header" href="#drop-dropwhile"><code>drop</code>, <code>dropWhile</code></a></h2>
<p><code>drop</code> and <code>dropWhile</code> are essentially the opposite of <code>take</code> and <code>takeWhile</code>. This is <code>drop</code>:</p>
<pre><code class="language-scala">scala&gt; nums.drop(1)
res0: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10)

scala&gt; nums.drop(5)
res1: List[Int] = List(6, 7, 8, 9, 10)

scala&gt; names.drop(1)
res2: List[String] = List(ed, chris, maurice)

scala&gt; names.drop(2)
res3: List[String] = List(chris, maurice)
</code></pre>
<p>And this is <code>dropWhile</code>:</p>
<pre><code class="language-scala">scala&gt; nums.dropWhile(_ &lt; 5)
res4: List[Int] = List(5, 6, 7, 8, 9, 10)

scala&gt; names.dropWhile(_ != &quot;chris&quot;)
res5: List[String] = List(chris, maurice)
</code></pre>
<h2 id="reduce"><a class="header" href="#reduce"><code>reduce</code></a></h2>
<p>When you hear the term, “map reduce,” the “reduce” part refers to methods like <code>reduce</code>. It takes a function (or anonymous function) and applies that function to successive elements in the list.</p>
<p>The best way to explain <code>reduce</code> is to create a little helper method you can pass into it. For example, this is an <code>add</code> method that adds two integers together, and also gives us some nice debug output:</p>
<pre><code class="language-scala">def add(x: Int, y: Int): Int = {
    val theSum = x + y
    println(s&quot;received $x and $y, their sum is $theSum&quot;)
    theSum
}
</code></pre>
<p>Now, given that method and this list:</p>
<pre><code class="language-scala">val a = List(1,2,3,4)
</code></pre>
<p>this is what happens when you pass the <code>add</code> method into <code>reduce</code>:</p>
<pre><code class="language-scala">scala&gt; a.reduce(add)
received 1 and 2, their sum is 3
received 3 and 3, their sum is 6
received 6 and 4, their sum is 10
res0: Int = 10
</code></pre>
<p>As that result shows, <code>reduce</code> uses <code>add</code> to reduce the list <code>a</code> into a single value, in this case, the sum of the integers in the list.</p>
<p>Once you get used to <code>reduce</code>, you’ll write a “sum” algorithm like this:</p>
<pre><code class="language-scala">scala&gt; a.reduce(_ + _)
res0: Int = 10
</code></pre>
<p>Similarly, this is what a “product” algorithm looks like:</p>
<pre><code class="language-scala">scala&gt; a.reduce(_ * _)
res1: Int = 24
</code></pre>
<p>That might be a little mind-blowing if you’ve never seen it before, but after a while you’ll get used to it.</p>
<blockquote>
<p>Before moving on, an important part to know about <code>reduce</code> is that — as its name implies — it’s used to <em>reduce</em> a collection down to a single value.</p>
</blockquote>
<h2 id="even-more-1"><a class="header" href="#even-more-1">Even more!</a></h2>
<p>There are literally dozens of additional methods on the Scala sequence classes that will keep you from ever needing to write another <code>for</code> loop. However, because this is a simple introduction book they won’t all be covered here. For more information, see <a href="%7B%7Bsite.baseurl%7D%7D/overviews/collections-2.13/seqs.html">the collections overview of sequence traits</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Common Map Methods
description: This page shows examples of the most common methods that are available on Scala Maps.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 36
outof: 54
previous-page: collections-methods
next-page: misc</h2>
<p>In this lesson we’ll demonstrate some of the most commonly used <code>Map</code> methods. In these initial examples we’ll use an <em>immutable</em> <code>Map</code>, and Scala also has a mutable <code>Map</code> class that you can modify in place, and it’s demonstrated a little later in this lesson.</p>
<p>For these examples we won’t break the <code>Map</code> methods down into individual sections; we’ll just provide a brief comment before each method.</p>
<p>Given this immutable <code>Map</code>:</p>
<pre><code class="language-scala">val m = Map(
    1 -&gt; &quot;a&quot;, 
    2 -&gt; &quot;b&quot;, 
    3 -&gt; &quot;c&quot;,
    4 -&gt; &quot;d&quot;
)
</code></pre>
<p>Here are some examples of methods available to that <code>Map</code>:</p>
<pre><code class="language-scala">// how to iterate over Map elements
scala&gt; for ((k,v) &lt;- m) printf(&quot;key: %s, value: %s\n&quot;, k, v)
key: 1, value: a
key: 2, value: b
key: 3, value: c
key: 4, value: d

// how to get the keys from a Map
scala&gt; val keys = m.keys
keys: Iterable[Int] = Set(1, 2, 3, 4)

// how to get the values from a Map
scala&gt; val values = m.values
val values: Iterable[String] = MapLike.DefaultValuesIterable(a, b, c, d)

// how to test if a Map contains a key
scala&gt; val contains3 = m.contains(3)
contains3: Boolean = true

// how to transform Map values
scala&gt; val ucMap = m.transform((k,v) =&gt; v.toUpperCase)
ucMap: scala.collection.immutable.Map[Int,String] = Map(1 -&gt; A, 2 -&gt; B, 3 -&gt; C, 4 -&gt; D)

// how to filter a Map by its keys
scala&gt; val twoAndThree = m.view.filterKeys(Set(2,3)).toMap
twoAndThree: scala.collection.immutable.Map[Int,String] = Map(2 -&gt; b, 3 -&gt; c)

// how to take the first two elements from a Map
scala&gt; val firstTwoElements = m.take(2)
firstTwoElements: scala.collection.immutable.Map[Int,String] = Map(1 -&gt; a, 2 -&gt; b)
</code></pre>
<blockquote>
<p>Note that the last example probably only makes sense for a sorted Map.</p>
</blockquote>
<h2 id="mutable-map-examples"><a class="header" href="#mutable-map-examples">Mutable Map examples</a></h2>
<p>Here are a few examples of methods that are available on the mutable <code>Map</code> class. Given this initial mutable <code>Map</code>:</p>
<pre><code class="language-scala">val states = scala.collection.mutable.Map(
    &quot;AL&quot; -&gt; &quot;Alabama&quot;, 
    &quot;AK&quot; -&gt; &quot;Alaska&quot;
)
</code></pre>
<p>Here are some things you can do with a mutable <code>Map</code>:</p>
<pre><code class="language-scala">// add elements with +=
states += (&quot;AZ&quot; -&gt; &quot;Arizona&quot;)
states ++= Map(&quot;CO&quot; -&gt; &quot;Colorado&quot;, &quot;KY&quot; -&gt; &quot;Kentucky&quot;)

// remove elements with -=
states -= &quot;KY&quot;
states --= List(&quot;AZ&quot;, &quot;CO&quot;)

// update elements by reassigning them
states(&quot;AK&quot;) = &quot;Alaska, The Big State&quot;

// filter elements by supplying a function that operates on
// the keys and/or values
states.filterInPlace((k,v) =&gt; k == &quot;AK&quot;)
</code></pre>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See also</a></h2>
<p>There are many more things you can do with maps. See the <a href="%7B%7Bsite.baseurl%7D%7D/overviews/collections-2.13/maps.html">Map class documentation</a> for more details and examples.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: A Few Miscellaneous Items
description: A few miscellaneous items about Scala
partof: scala_book
overview-name: Scala Book
discourse: true
num: 37
outof: 54
previous-page: collections-maps
next-page: tuples</h2>
<p>In this section we’ll cover a few miscellaneous items about Scala:</p>
<ul>
<li>Tuples</li>
<li>A Scala OOP example of a pizza restaurant order-entry system</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Tuples
description: This page is an introduction to the Scala 'tuple' data type, showing examples of how to use tuples in your Scala code.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 38
outof: 54
previous-page: misc
next-page: oop-pizza-example</h2>
<p>A <em>tuple</em> is a neat class that gives you a simple way to store <em>heterogeneous</em> (different) items in the same container. For example, assuming that you have a class like this:</p>
<pre><code class="language-scala">class Person(var name: String)
</code></pre>
<p>Instead of having to create an ad-hoc class to store things in, like this:</p>
<pre><code class="language-scala">class SomeThings(i: Int, s: String, p: Person)
</code></pre>
<p>you can just create a tuple like this:</p>
<pre><code class="language-scala">val t = (3, &quot;Three&quot;, new Person(&quot;Al&quot;))
</code></pre>
<p>As shown, just put some elements inside parentheses, and you have a tuple. Scala tuples can contain between two and 22 items, and they’re useful for those times when you just need to combine a few things together, and don’t want the baggage of having to define a class, especially when that class feels a little “artificial” or phony.</p>
<blockquote>
<p>Technically, Scala 2.x has classes named <code>Tuple2</code>, <code>Tuple3</code> ... up to <code>Tuple22</code>. As a practical matter you rarely need to know this, but it’s also good to know what’s going on under the hood. (And this architecture is being improved in Scala 3.)</p>
</blockquote>
<h2 id="a-few-more-tuple-details"><a class="header" href="#a-few-more-tuple-details">A few more tuple details</a></h2>
<p>Here’s a two-element tuple:</p>
<pre><code class="language-scala">scala&gt; val d = (&quot;Maggie&quot;, 30)
d: (String, Int) = (Maggie,30)
</code></pre>
<p>Notice that it contains two different types. Here’s a three-element tuple:</p>
<pre><code class="language-scala">scala&gt; case class Person(name: String)
defined class Person

scala&gt; val t = (3, &quot;Three&quot;, new Person(&quot;David&quot;))
t: (Int, java.lang.String, Person) = (3,Three,Person(David))
</code></pre>
<p>There are a few ways to access tuple elements. One approach is to access them by element number, where the number is preceded by an underscore:</p>
<pre><code class="language-scala">scala&gt; t._1
res1: Int = 3

scala&gt; t._2
res2: java.lang.String = Three

scala&gt; t._3
res3: Person = Person(David)
</code></pre>
<p>Another cool approach is to access them like this:</p>
<pre><code class="language-scala">scala&gt; val(x, y, z) = (3, &quot;Three&quot;, new Person(&quot;David&quot;))
x: Int = 3
y: String = Three
z: Person = Person(David)
</code></pre>
<p>Technically this approach involves a form of pattern-matching, and it’s a great way to assign tuple elements to variables.</p>
<h2 id="returning-a-tuple-from-a-method"><a class="header" href="#returning-a-tuple-from-a-method">Returning a tuple from a method</a></h2>
<p>A place where this is nice is when you want to return multiple values from a method. For example, here’s a method that returns a tuple:</p>
<pre><code class="language-scala">def getStockInfo = {
    // other code here ...
    (&quot;NFLX&quot;, 100.00, 101.00)  // this is a Tuple3
}
</code></pre>
<p>Now you can call that method and assign variable names to the return values: </p>
<pre><code class="language-scala">val (symbol, currentPrice, bidPrice) = getStockInfo
</code></pre>
<p>The REPL demonstrates how this works:</p>
<pre><code class="language-scala">scala&gt; val (symbol, currentPrice, bidPrice) = getStockInfo
symbol: String = NFLX
currentPrice: Double = 100.0
bidPrice: Double = 101.0
</code></pre>
<p>For cases like this where it feels like overkill to create a class for the method’s return type, a tuple is very convenient.</p>
<h2 id="tuples-arent-collections"><a class="header" href="#tuples-arent-collections">Tuples aren’t collections</a></h2>
<p>Technically, Scala 2.x tuples aren’t collections classes, they’re just a convenient little container. Because they aren’t a collection, they don’t have methods like <code>map</code>, <code>filter</code>, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: An OOP Example
description: This lesson shares an example of some OOP-style classes for a pizza restaurant order entry system, including Pizza, Topping, and Order classes.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 39
outof: 54
previous-page: tuples
next-page: sbt-scalatest-intro</h2>
<p>This lesson shares an example of an OOP application written with Scala. The example shows code you might write for an order-entry system for a pizza store.</p>
<p>As shown earlier in the book, you create enumerations in Scala like this:</p>
<pre><code class="language-scala">sealed trait Topping
case object Cheese extends Topping
case object Pepperoni extends Topping
case object Sausage extends Topping
case object Mushrooms extends Topping
case object Onions extends Topping

sealed trait CrustSize
case object SmallCrustSize extends CrustSize
case object MediumCrustSize extends CrustSize
case object LargeCrustSize extends CrustSize

sealed trait CrustType
case object RegularCrustType extends CrustType
case object ThinCrustType extends CrustType
case object ThickCrustType extends CrustType
</code></pre>
<p>A nice thing about Scala is that even though we haven’t discussed sealed traits or case objects, you can probably still figure out how this code works.</p>
<h2 id="a-few-classes"><a class="header" href="#a-few-classes">A few classes</a></h2>
<p>Given those enumerations, you can now start to create a few pizza-related classes for an order-entry system. First, here’s a <code>Pizza</code> class:</p>
<pre><code class="language-scala">import scala.collection.mutable.ArrayBuffer

class Pizza (
    var crustSize: CrustSize,
    var crustType: CrustType,
    var toppings: ArrayBuffer[Topping]
)
</code></pre>
<p>Next, here’s an <code>Order</code> class, where an <code>Order</code> consists of a mutable list of pizzas and a <code>Customer</code>:</p>
<pre><code class="language-scala">class Order (
    var pizzas: ArrayBuffer[Pizza],
    var customer: Customer
)
</code></pre>
<p>Here’s a <code>Customer</code> class to work with that code:</p>
<pre><code class="language-scala">class Customer (
    var name: String,
    var phone: String,
    var address: Address
)
</code></pre>
<p>Finally, here’s an <code>Address</code> class:</p>
<pre><code class="language-scala">class Address (
    var street1: String,
    var street2: String,
    var city: String,
    var state: String,
    var zipCode: String
)
</code></pre>
<p>So far those classes just look like data structures — like a <code>struct</code> in C — so let’s add a little behavior.</p>
<h2 id="adding-behavior-to-pizza"><a class="header" href="#adding-behavior-to-pizza">Adding behavior to Pizza</a></h2>
<p>For the most part an OOP <code>Pizza</code> class needs a few methods to add and remove toppings, and adjust the crust size and type. Here’s a <code>Pizza</code> class with a few added methods to handle those behaviors:</p>
<pre><code class="language-scala">class Pizza (
    var crustSize: CrustSize,
    var crustType: CrustType,
    val toppings: ArrayBuffer[Topping]
) {

    def addTopping(t: Topping): Unit = toppings += t
    def removeTopping(t: Topping): Unit = toppings -= t
    def removeAllToppings(): Unit = toppings.clear()

}
</code></pre>
<p>You can also argue that a pizza should be able to calculate its own price, so here’s another method you could add to that class:</p>
<pre><code class="language-scala">def getPrice(
    toppingsPrices: Map[Topping, Int],
    crustSizePrices: Map[CrustSize, Int],
    crustTypePrices: Map[CrustType, Int]
): Int = ???
</code></pre>
<p>Note that this is a perfectly legal method. The <code>???</code> syntax is often used as a teaching tool, and sometimes you use it as a method-sketching tool to say, “This is what my method signature looks like, but I don’t want to write the method body yet.” A great thing for those times is that this code compiles.</p>
<blockquote>
<p>That being said, don’t <em>call</em> that method. If you do, you’ll get a <code>NotImplementedError</code>, which is very descriptive of the situation.</p>
</blockquote>
<h2 id="adding-behavior-to-order"><a class="header" href="#adding-behavior-to-order">Adding behavior to Order</a></h2>
<p>You should be able to do a few things with an order, including:</p>
<ul>
<li>Add and remove pizzas</li>
<li>Update customer information</li>
<li>Get the order price</li>
</ul>
<p>Here’s an <code>Order</code> class that lets you do those things:</p>
<pre><code class="language-scala">class Order (
    val pizzas: ArrayBuffer[Pizza],
    var customer: Customer
) {

    def addPizza(p: Pizza): Unit = pizzas += p
    def removePizza(p: Pizza): Unit = pizzas -= p

    // need to implement these
    def getBasePrice(): Int = ???
    def getTaxes(): Int = ???
    def getTotalPrice(): Int = ???

}
</code></pre>
<p>Once again, for the purposes of this example, we’re not concerned with how to calculate the price of an order.</p>
<h2 id="testing-those-classes"><a class="header" href="#testing-those-classes">Testing those classes</a></h2>
<p>You can use a little “driver” class to test those classes. With the addition of a <code>printOrder</code> method on the <code>Order</code> class and a <code>toString</code> method in the <code>Pizza</code> class, you’ll find that the code shown works as advertised:</p>
<pre><code class="language-scala">import scala.collection.mutable.ArrayBuffer

object MainDriver extends App {

    val p1 = new Pizza (
        MediumCrustSize,
        ThinCrustType,
        ArrayBuffer(Cheese)
    )

    val p2 = new Pizza (
        LargeCrustSize,
        ThinCrustType,
        ArrayBuffer(Cheese, Pepperoni, Sausage)
    )

    val address = new Address (
        &quot;123 Main Street&quot;,
        &quot;Apt. 1&quot;,
        &quot;Talkeetna&quot;,
        &quot;Alaska&quot;,
        &quot;99676&quot;
    )

    val customer = new Customer (
        &quot;Alvin Alexander&quot;,
        &quot;907-555-1212&quot;,
        address
    )

    val o = new Order(
        ArrayBuffer(p1, p2),
        customer
    )

    o.addPizza(
        new Pizza (
            SmallCrustSize,
            ThinCrustType,
            ArrayBuffer(Cheese, Mushrooms)
        )
    )

    // print the order
    o.printOrder

}
</code></pre>
<h2 id="experiment-with-the-code-yourself"><a class="header" href="#experiment-with-the-code-yourself">Experiment with the code yourself</a></h2>
<p>To experiment with this on your own, please see the <em>PizzaOopExample</em> project in this book’s GitHub repository, which you can find at this URL:</p>
<ul>
<li><a href="https://github.com/alvinj/HelloScalaExamples">github.com/alvinj/HelloScalaExamples</a></li>
</ul>
<p>To compile this project it will help to either (a) use IntelliJ IDEA or Eclipse, or (b) know how to use the <a href="http://www.scala-sbt.org">Scala Build Tool</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: sbt and ScalaTest
description: In this lesson we'll start to introduce sbt and ScalaTest, two tools commonly used on Scala projects.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 40
outof: 54
previous-page: oop-pizza-example
next-page: scala-build-tool-sbt</h2>
<p>In the next few lessons you’ll see a couple of tools that are commonly used in Scala projects:</p>
<ul>
<li>The <a href="http://www.scala-sbt.org">sbt build tool</a></li>
<li><a href="http://www.scalatest.org">ScalaTest</a>, a code testing framework</li>
</ul>
<p>We’ll start by showing how to use sbt, and then you’ll see how to use ScalaTest and sbt together to build and test your Scala projects.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: The most used scala build tool (sbt)
description: This page provides an introduction to the Scala Build Tool, sbt, including a simple 'Hello, world' project.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 41
outof: 54
previous-page: sbt-scalatest-intro
next-page: sbt-scalatest-tdd</h2>
<p>You can use several different tools to build your Scala projects, including Ant, Maven, Gradle, and more. But a tool named <a href="http://www.scala-sbt.org">sbt</a> was the first build tool that was specifically created for Scala, and these days it’s supported by <a href="https://www.lightbend.com">Lightbend</a>, the company that was co-founded by Scala creator Martin Odersky that also maintains Akka, the Play web framework, and more.</p>
<blockquote>
<p>If you haven’t already installed sbt, here’s a link to <a href="http://www.scala-sbt.org/download.html">its download page</a>.</p>
</blockquote>
<h2 id="the-sbt-directory-structure"><a class="header" href="#the-sbt-directory-structure">The sbt directory structure</a></h2>
<p>Like Maven, sbt uses a standard project directory structure. If you use that standard directory structure you’ll find that it’s relatively simple to build your first projects.</p>
<p>The first thing to know is that underneath your main project directory, sbt expects a directory structure that looks like this:</p>
<pre><code class="language-bash">build.sbt
project/
src/
-- main/
   |-- java/
   |-- resources/
   |-- scala/
|-- test/
   |-- java/
   |-- resources/
   |-- scala/
target/
</code></pre>
<h2 id="creating-a-hello-world-sbt-project-directory-structure"><a class="header" href="#creating-a-hello-world-sbt-project-directory-structure">Creating a “Hello, world” sbt project directory structure</a></h2>
<p>Creating this directory structure is pretty simple, and you can use a shell script like <a href="https://alvinalexander.com/sbtmkdirs">sbtmkdirs</a> to create new projects. But you don’t have to use that script; assuming that you’re using a Unix/Linux system, you can just use these commands to create your first sbt project directory structure:</p>
<pre><code class="language-bash">mkdir HelloWorld
cd HelloWorld
mkdir -p src/{main,test}/{java,resources,scala}
mkdir project target
</code></pre>
<p>If you run a <code>find .</code> command after running those commands, you should see this result:</p>
<pre><code class="language-bash">$ find .
.
./project
./src
./src/main
./src/main/java
./src/main/resources
./src/main/scala
./src/test
./src/test/java
./src/test/resources
./src/test/scala
./target
</code></pre>
<p>If you see that, you’re in great shape for the next step.</p>
<blockquote>
<p>There are other ways to create the files and directories for an sbt project. One way is to use the <code>sbt new</code> command, <a href="http://www.scala-sbt.org/1.x/docs/Hello.html">which is documented here on scala-sbt.org</a>. That approach isn’t shown here because some of the files it creates are more complicated than necessary for an introduction like this.</p>
</blockquote>
<h2 id="creating-a-first-buildsbt-file"><a class="header" href="#creating-a-first-buildsbt-file">Creating a first <em>build.sbt</em> file</a></h2>
<p>At this point you only need two more things to run a “Hello, world” project:</p>
<ul>
<li>A <em>build.sbt</em> file</li>
<li>A <em>HelloWorld.scala</em> file</li>
</ul>
<p>For a little project like this, the <em>build.sbt</em> file only needs to contain a few lines, like this:</p>
<pre><code class="language-scala">name := &quot;HelloWorld&quot;
version := &quot;1.0&quot;
scalaVersion := &quot;{{ site.scala-version }}&quot;
</code></pre>
<p>Because sbt projects use a standard directory structure, sbt already knows everything else it needs to know.</p>
<p>Now you just need to add a little “Hello, world” program.</p>
<h2 id="a-hello-world-program"><a class="header" href="#a-hello-world-program">A “Hello, world” program</a></h2>
<p>In large projects, all of your Scala source code files will go under the <em>src/main/scala</em> and <em>src/test/scala</em> directories, but for a little sample project like this, you can put your source code file in the root directory of your project. Therefore, create a file named <em>HelloWorld.scala</em> in the root directory with these contents:</p>
<pre><code class="language-scala">object HelloWorld extends App {
    println(&quot;Hello, world&quot;)
}
</code></pre>
<p>Now you can use sbt to compile your project, where in this example, your project consists of that one file. Use the <code>sbt run</code> command to compile and run your project. When you do so, you’ll see output that looks like this:</p>
<pre><code>$ sbt run

Updated file /Users/al/Projects/Scala/Hello/project/build.properties setting sbt.version to: 0.13.15
[warn] Executing in batch mode.
[warn]   For better performance, hit [ENTER] to switch to interactive mode, or
[warn]   consider launching sbt without any commands, or explicitly passing 'shell'
[info] Loading project definition from /Users/al/Projects/Scala/Hello/project
[info] Updating {file:/Users/al/Projects/Scala/Hello/project/}hello-build...
[info] Resolving org.fusesource.jansi#jansi;1.4 ...
[info] Done updating.
[info] Set current project to Hello (in build file:/Users/al/Projects/Scala/Hello/)
[info] Updating {file:/Users/al/Projects/Scala/Hello/}hello...
[info] Resolving jline#jline;2.14.5 ...
[info] Done updating.
[info] Compiling 1 Scala source to /Users/al/Projects/Scala/Hello/target/scala-2.12/classes...
[info] Running HelloWorld 
Hello, world
[success] Total time: 4 s
</code></pre>
<p>The first time you run <code>sbt</code> it needs to download some things and can take a while to run, but after that it gets much faster. As the first comment in that output shows, it’s also faster to run sbt interactively. To do that, first run the <code>sbt</code> command by itself:</p>
<pre><code>&gt; sbt
[info] Loading project definition from /Users/al/Projects/Scala/Hello/project
[info] Set current project to Hello (in build file:/Users/al/Projects/Scala/Hello/)
</code></pre>
<p>The execute its <code>run</code> command like this:</p>
<pre><code>&gt; run
[info] Running HelloWorld 
Hello, world
[success] Total time: 0 s
</code></pre>
<p>There, that’s much faster.</p>
<p>If you type <code>help</code> at the sbt command prompt you’ll see a bunch of other commands you can run. But for now, just type <code>exit</code> to leave the sbt shell. You can also press <code>CTRL-D</code> instead of typing <code>exit</code>.</p>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See also</a></h2>
<p>Here’s a list of other build tools you can use to build Scala projects:</p>
<ul>
<li><a href="http://ant.apache.org/">Ant</a></li>
<li><a href="https://gradle.org/">Gradle</a></li>
<li><a href="https://maven.apache.org/">Maven</a></li>
<li><a href="https://propensive.com/opensource/fury">Fury</a></li>
<li><a href="https://com-lihaoyi.github.io/mill/">Mill</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Using ScalaTest with sbt
description: This lesson shows how to write ScalaTest unit tests with sbt in a test-driven development (TDD) style.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 42
outof: 54
previous-page: scala-build-tool-sbt
next-page: sbt-scalatest-bdd</h2>
<p><a href="http://www.scalatest.org">ScalaTest</a> is one of the main testing libraries for Scala projects, and in this lesson you’ll see how to create a Scala project that uses ScalaTest. You’ll also be able to compile, test, and run the project with sbt.</p>
<h2 id="creating-the-project-directory-structure"><a class="header" href="#creating-the-project-directory-structure">Creating the project directory structure</a></h2>
<p>As with the previous lesson, create an sbt project directory structure for a project named <em>HelloScalaTest</em> with the following commands:</p>
<pre><code class="language-sh">mkdir HelloScalaTest
cd HelloScalaTest
mkdir -p src/{main,test}/{java,resources,scala}
mkdir lib project target
</code></pre>
<h2 id="creating-the-buildsbt-file"><a class="header" href="#creating-the-buildsbt-file">Creating the <em>build.sbt</em> file</a></h2>
<p>Next, create a <em>build.sbt</em> file in the root directory of your project with these contents:</p>
<pre><code class="language-scala">name := &quot;HelloScalaTest&quot;
version := &quot;1.0&quot;
scalaVersion := &quot;{{site.scala-version}}&quot;

libraryDependencies +=
    &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.8&quot; % Test

</code></pre>
<p>The first three lines of this file are essentially the same as the first example, and the <code>libraryDependencies</code> lines tell sbt to include the dependencies (jar files) that are needed to run ScalaTest:</p>
<pre><code class="language-scala">libraryDependencies +=
    &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;3.0.8&quot; % Test
</code></pre>
<blockquote>
<p>The ScalaTest documentation has always been good, and you can always find the up to date information on what those lines should look like on the <a href="http://www.scalatest.org/install">Installing ScalaTest</a> page.</p>
</blockquote>
<h2 id="create-a-scala-file"><a class="header" href="#create-a-scala-file">Create a Scala file</a></h2>
<p>Next, create a Scala program that you can use to demonstrate ScalaTest. First, from the root directory of your project, create a directory under <em>src/main/scala</em> named <em>simpletest</em>:</p>
<pre><code class="language-sh">$ mkdir src/main/scala/simpletest
</code></pre>
<p>Then, inside that directory, create a file named <em>Hello.scala</em> with these contents:</p>
<pre><code class="language-scala">package simpletest

object Hello extends App {
    val p = new Person(&quot;Alvin Alexander&quot;)
    println(s&quot;Hello ${p.name}&quot;)
}

class Person(var name: String)
</code></pre>
<p>There isn’t much that can go wrong with that source code, but it provides a simple way to demonstrate ScalaTest. At this point you can run your project with the <code>sbt run</code> command, where your output should look like this:</p>
<pre><code>&gt; sbt run

[warn] Executing in batch mode.
[warn]   For better performance, hit [ENTER] to switch to interactive mode, or
[warn]   consider launching sbt without any commands, or explicitly passing 'shell'
...
...
[info] Compiling 1 Scala source to /Users/al/Projects/Scala/HelloScalaTest/target/scala-2.12/classes...
[info] Running simpletest.Hello 
Hello Alvin Alexander
[success] Total time: 4 s
</code></pre>
<p>Now let’s create a ScalaTest file.</p>
<h2 id="your-first-scalatest-tests"><a class="header" href="#your-first-scalatest-tests">Your first ScalaTest tests</a></h2>
<p>ScalaTest is very flexible, and there are a lot of different ways to write tests, but a simple way to get started is to write tests using the ScalaTest “FunSuite.” To get started, create a directory named <em>simpletest</em> under the <em>src/test/scala</em> directory, like this:</p>
<pre><code class="language-sh">$ mkdir src/test/scala/simpletest
</code></pre>
<p>Next, create a file named <em>HelloTests.scala</em> in that directory with the following contents:</p>
<pre><code class="language-scala">package simpletest

import org.scalatest.FunSuite

class HelloTests extends FunSuite {

    // test 1
    test(&quot;the name is set correctly in constructor&quot;) {
        val p = new Person(&quot;Barney Rubble&quot;)
        assert(p.name == &quot;Barney Rubble&quot;)
    }

    // test 2
    test(&quot;a Person's name can be changed&quot;) {
        val p = new Person(&quot;Chad Johnson&quot;)
        p.name = &quot;Ochocinco&quot;
        assert(p.name == &quot;Ochocinco&quot;)
    }

}
</code></pre>
<p>This file demonstrates the ScalaTest <code>FunSuite</code> approach. A few important points:</p>
<ul>
<li>Your class should extend <code>FunSuite</code></li>
<li>You create tests as shown, by giving each <code>test</code> a unique name</li>
<li>At the end of each test you should call <code>assert</code> to test that a condition has been satisfied</li>
</ul>
<p>Using ScalaTest like this is similar to JUnit, so if you’re coming to Scala from Java, hopefully this looks very familiar.</p>
<p>Now you can run these tests with the <code>sbt test</code> command. Skipping the first few lines of output, the result looks like this:</p>
<pre><code>&gt; sbt test
[info] Set current project to HelloScalaTest (in build file:/Users/al/Projects/Scala/HelloScalaTest/)
[info] HelloTests:
[info] - the name is set correctly in constructor
[info] - a Person's name can be changed
[info] Run completed in 277 milliseconds.
[info] Total number of tests run: 2
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 2, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.
[success] Total time: 1 s
</code></pre>
<h2 id="tdd-tests"><a class="header" href="#tdd-tests">TDD tests</a></h2>
<p>This example demonstrates a <em>Test-Driven Development</em> (TDD) style of testing with ScalaTest. In the next lesson you’ll see how to write <em>Behavior-Driven Development</em> (BDD) tests with ScalaTest and sbt.</p>
<blockquote>
<p>Keep the project you just created. You’ll use it again in the next lesson.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Writing BDD Style Tests with ScalaTest and sbt
description: This lesson shows how to write ScalaTest unit tests with sbt in a behavior-driven development (TDD) style.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 43
outof: 54
previous-page: sbt-scalatest-tdd
next-page: functional-programming</h2>
<p>In the previous lesson you saw how to write Test-Driven Development (TDD) tests with <a href="http://www.scalatest.org">ScalaTest</a>. ScalaTest also supports a <a href="https://dannorth.net/introducing-bdd/">Behavior-Driven Development (BDD)</a> style of testing, which we’ll demonstrate next.</p>
<blockquote>
<p>This lesson uses the same sbt project as the previous lesson, so you don’t have to go through the initial setup work again.</p>
</blockquote>
<h2 id="creating-a-scala-class-to-test"><a class="header" href="#creating-a-scala-class-to-test">Creating a Scala class to test</a></h2>
<p>First, create a new Scala class to test. In the <em>src/main/scala/simpletest</em>, create a new file named <em>MathUtils.scala</em> with these contents:</p>
<pre><code class="language-scala">package simpletest

object MathUtils {

    def double(i: Int) = i * 2

}
</code></pre>
<p>The BDD tests you’ll write next will test the <code>double</code> method in that class.</p>
<h2 id="creating-scalatest-bdd-style-tests"><a class="header" href="#creating-scalatest-bdd-style-tests">Creating ScalaTest BDD-style tests</a></h2>
<p>Next, create a file named <em>MathUtilsTests.scala</em> in the <em>src/test/scala/simpletest</em> directory, and put these contents in that file:</p>
<pre><code class="language-scala">package simpletest

import org.scalatest.FunSpec

class MathUtilsSpec extends FunSpec {
  
    describe(&quot;MathUtils::double&quot;) {

        it(&quot;should handle 0 as input&quot;) {
            val result = MathUtils.double(0)
            assert(result == 0)
        }

        it(&quot;should handle 1&quot;) {
            val result = MathUtils.double(1)
            assert(result == 2)
        }

        it(&quot;should handle really large integers&quot;) (pending)
        
    }

}
</code></pre>
<p>As you can see, this is a very different-looking style than the TDD tests in the previous lesson. If you’ve never used a BDD style of testing before, a main idea is that the tests should be relatively easy to read for one of the “domain experts” who work with the programmers to create the application. A few notes about this code:</p>
<ul>
<li>It uses the <code>FunSpec</code> class where the TDD tests used <code>FunSuite</code></li>
<li>A set of tests begins with <code>describe</code></li>
<li>Each test begins with <code>it</code>. The idea is that the test should read like, “It should do XYZ...,” where “it” is the <code>double</code> function</li>
<li>This example also shows how to mark a test as “pending”</li>
</ul>
<h2 id="running-the-tests"><a class="header" href="#running-the-tests">Running the tests</a></h2>
<p>With those files in place you can again run <code>sbt test</code>. The important part of the output looks like this:</p>
<pre><code>&gt; sbt test

[info] HelloTests:
[info] - the name is set correctly in constructor
[info] - a Person's name can be changed
[info] MathUtilsSpec:
[info] MathUtils::double
[info] - should handle 0 as input
[info] - should handle 1
[info] - should handle really large integers (pending)
[info] Total number of tests run: 4
[info] Suites: completed 2, aborted 0
[info] Tests: succeeded 4, failed 0, canceled 0, ignored 0, pending 1
[info] All tests passed.
[success] Total time: 4 s, completed Jan 6, 2018 4:58:23 PM
</code></pre>
<p>A few notes about that output:</p>
<ul>
<li><code>sbt test</code> ran the previous <code>HelloTests</code> as well as the new <code>MathUtilsSpec</code> tests</li>
<li>The pending test shows up in the output and is marked “(pending)”</li>
<li>All of the tests passed</li>
</ul>
<p>If you want to have a little fun with this, change one or more of the tests so they intentionally fail, and then see what the output looks like.</p>
<h2 id="where-to-go-from-here"><a class="header" href="#where-to-go-from-here">Where to go from here</a></h2>
<p>For more information about sbt and ScalaTest, see the following resources:</p>
<ul>
<li><a href="http://www.scala-sbt.org/documentation.html">The main sbt documentation</a></li>
<li><a href="http://www.scalatest.org/user_guide">The ScalaTest documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: Functional Programming
description: This lesson begins a second on 'An introduction to functional programming in Scala'.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 44
outof: 54
previous-page: sbt-scalatest-bdd
next-page: pure-functions</h2>
<p>Scala lets you write code in an object-oriented programming (OOP) style, a functional programming (FP) style, and even in a hybrid style, using both approaches in combination. This book assumes that you’re coming to Scala from an OOP language like Java, C++, or C#, so outside of covering Scala classes, there aren’t any special sections about OOP in this book. But because the FP style is still relatively new to many developers, we’ll provide a brief introduction to Scala’s support for FP in the next several lessons.</p>
<p><em>Functional programming</em> is a style of programming that emphasizes writing applications using only pure functions and immutable values. As Alvin Alexander wrote in <a href="https://alvinalexander.com/scala/functional-programming-simplified-book">Functional Programming, Simplified</a>, rather than using that description, it can be helpful to say that functional programmers have an extremely strong desire to see their code as math — to see the combination of their functions as a series of algebraic equations. In that regard, you could say that functional programmers like to think of themselves as mathematicians. That’s the driving desire that leads them to use <em>only</em> pure functions and immutable values, because that’s what you use in algebra and other forms of math.</p>
<p>Functional programming is a large topic, and there’s no simple way to condense the entire topic into this little book, but in the following lessons we’ll give you a taste of FP, and show some of the tools Scala provides for developers to write functional code.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Pure Functions
description: This lesson provides an introduction to writing pure functions in Scala.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 45
outof: 54
previous-page: functional-programming
next-page: passing-functions-around</h2>
<p>A first feature Scala offers to help you write functional code is the ability to write pure functions. In <a href="https://alvinalexander.com/scala/functional-programming-simplified-book">Functional Programming, Simplified</a>, Alvin Alexander defines a <em>pure function</em> like this:</p>
<ul>
<li>The function’s output depends <em>only</em> on its input variables</li>
<li>It doesn’t mutate any hidden state</li>
<li>It doesn’t have any “back doors”: It doesn’t read data from the outside world (including the console, web services, databases, files, etc.), or write data to the outside world</li>
</ul>
<p>As a result of this definition, any time you call a pure function with the same input value(s), you’ll always get the same result. For example, you can call a <code>double</code> function an infinite number of times with the input value <code>2</code>, and you’ll always get the result <code>4</code>.</p>
<h2 id="examples-of-pure-functions"><a class="header" href="#examples-of-pure-functions">Examples of pure functions</a></h2>
<p>Given that definition of pure functions, as you might imagine, methods like these in the <em>scala.math._</em> package are pure functions:</p>
<ul>
<li><code>abs</code></li>
<li><code>ceil</code></li>
<li><code>max</code></li>
<li><code>min</code></li>
</ul>
<p>These Scala <code>String</code> methods are also pure functions:</p>
<ul>
<li><code>isEmpty</code></li>
<li><code>length</code></li>
<li><code>substring</code></li>
</ul>
<p>Many methods on the Scala collections classes also work as pure functions, including <code>drop</code>, <code>filter</code>, and <code>map</code>.</p>
<h2 id="examples-of-impure-functions"><a class="header" href="#examples-of-impure-functions">Examples of impure functions</a></h2>
<p>Conversely, the following functions are <em>impure</em> because they violate the definition.</p>
<p>The <code>foreach</code> method on collections classes is impure because it’s only used for its side effects, such as printing to STDOUT.</p>
<blockquote>
<p>A great hint that <code>foreach</code> is impure is that it’s method signature declares that it returns the type <code>Unit</code>. Because it returns nothing, logically the only reason you ever call it is to achieve some side effect. Similarly, <em>any</em> method that returns <code>Unit</code> is going to be an impure function.</p>
</blockquote>
<p>Date and time related methods like <code>getDayOfWeek</code>, <code>getHour</code>, and <code>getMinute</code> are all impure because their output depends on something other than their input parameters. Their results rely on some form of hidden I/O, <em>hidden input</em> in these examples.</p>
<p>In general, impure functions do one or more of these things:</p>
<ul>
<li>Read hidden inputs, i.e., they access variables and data not explicitly passed into the function as input parameters</li>
<li>Write hidden outputs</li>
<li>Mutate the parameters they are given</li>
<li>Perform some sort of I/O with the outside world</li>
</ul>
<h2 id="but-impure-functions-are-needed-"><a class="header" href="#but-impure-functions-are-needed-">But impure functions are needed ...</a></h2>
<p>Of course an application isn’t very useful if it can’t read or write to the outside world, so people make this recommendation:</p>
<blockquote>
<p>Write the core of your application using pure functions, and then write an impure “wrapper” around that core to interact with the outside world. If you like food analogies, this is like putting a layer of impure icing on top of a pure cake.</p>
</blockquote>
<p>There are ways to make impure interactions with the outside world feel a little more pure. For instance, you’ll hear about things like the <code>IO</code> Monad for dealing with user input, files, networks, and databases. But in the end, FP applications have a core of pure functions combined with other functions to interact with the outside world.</p>
<h2 id="writing-pure-functions"><a class="header" href="#writing-pure-functions">Writing pure functions</a></h2>
<p>Writing pure functions in Scala is one of the simpler parts about functional programming: You just write pure functions using Scala’s method syntax. Here’s a pure function that doubles the input value it’s given:</p>
<pre><code class="language-scala">def double(i: Int): Int = i * 2
</code></pre>
<p>Although recursion isn’t covered in this book, if you like a good “challenge” example, here’s a pure function that calculates the sum of a list of integers (<code>List[Int]</code>):</p>
<pre><code class="language-scala">def sum(list: List[Int]): Int = list match {
    case Nil =&gt; 0
    case head :: tail =&gt; head + sum(tail)
}
</code></pre>
<p>Even though we haven’t covered recursion, if you can understand that code, you’ll see that it meets my definition of a pure function.</p>
<h2 id="key-points-1"><a class="header" href="#key-points-1">Key points</a></h2>
<p>The first key point of this lesson is the definition of a pure function:</p>
<blockquote>
<p>A <em>pure function</em> is a function that depends only on its declared inputs and its internal algorithm to produce its output. It does not read any other values from “the outside world” — the world outside of the function’s scope — and it does not modify any values in the outside world.</p>
</blockquote>
<p>A second key point is that real-world applications consist of a combination of pure and impure functions. A common recommendation is to write the core of your application using pure functions, and then to use impure functions to communicate with the outside world.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Passing Functions Around
description: Like a good functional programming language, Scala lets you use functions just like other variables, including passing them into other functions.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 46
outof: 54
previous-page: pure-functions
next-page: no-null-values</h2>
<p>While every programming language ever created probably lets you write pure functions, a second great FP feature of Scala is that <em>you can create functions as variables</em>, just like you create <code>String</code> and <code>Int</code> variables. This feature has many benefits, the most common of which is that it lets you pass functions as parameters into other functions. You saw that earlier in this book when the <code>map</code> and <code>filter</code> methods were demonstrated:</p>
<pre><code class="language-scala">val nums = (1 to 10).toList

val doubles = nums.map(_ * 2)
val lessThanFive = nums.filter(_ &lt; 5)
</code></pre>
<p>In those examples, anonymous functions are passed into <code>map</code> and <code>filter</code>. In the lesson on anonymous functions we demonstrated that this example:</p>
<pre><code class="language-scala">val doubles = nums.map(_ * 2)
</code></pre>
<p>is the same as passing a regular function into <code>map</code>:</p>
<pre><code class="language-scala">def double(i: Int): Int = i * 2   //a method that doubles an Int
val doubles = nums.map(double)
</code></pre>
<p>As those examples show, Scala clearly lets you pass anonymous functions and regular functions into other methods. This is a powerful feature that good FP languages provide.</p>
<blockquote>
<p>If you like technical terms, a function that takes another function as an input parameter is known as a <em>Higher-Order Function</em> (HOF). (And if you like humor, as someone once wrote, that’s like saying that a class that takes an instance of another class as a constructor parameter is a Higher-Order Class.)</p>
</blockquote>
<h2 id="function-or-method"><a class="header" href="#function-or-method">Function or method?</a></h2>
<p>Scala has <a href="https://alvinalexander.com/scala/fp-book-diffs-val-def-scala-functions">a special “function” syntax</a>, but as a practical matter the <code>def</code> syntax seems to be preferred. This may be because of two reasons:</p>
<ul>
<li>The <code>def</code> syntax is more familiar to people coming from a C/Java/C# background</li>
<li>You can use <code>def</code> methods just like they are <code>val</code> functions</li>
</ul>
<p>What that second statement means is that when you define a method with <code>def</code> like this:</p>
<pre><code class="language-scala">def double(i: Int): Int = i * 2
</code></pre>
<p>you can then pass <code>double</code> around as if it were a variable, like this:</p>
<pre><code class="language-scala">val x = ints.map(double)
                 ------
</code></pre>
<p>Even though <code>double</code> is defined as a <em>method</em>, Scala lets you treat it as a <em>function</em>.</p>
<p>The ability to pass functions around as variables is a distinguishing feature of functional programming languages. And as you’ve seen in <code>map</code> and <code>filter</code> examples in this book, the ability to pass functions as parameters into other functions helps you create code that is concise and still readable.</p>
<h2 id="a-few-examples"><a class="header" href="#a-few-examples">A few examples</a></h2>
<p>If you’re not comfortable with the process of passing functions as parameters into other functions, here are a few more examples you can experiment with in the REPL:</p>
<pre><code class="language-scala">List(&quot;foo&quot;, &quot;bar&quot;).map(_.toUpperCase)
List(&quot;foo&quot;, &quot;bar&quot;).map(_.capitalize)
List(&quot;adam&quot;, &quot;scott&quot;).map(_.length)
List(1,2,3,4,5).map(_ * 10)
List(1,2,3,4,5).filter(_ &gt; 2)
List(5,1,3,11,7).takeWhile(_ &lt; 6)
</code></pre>
<p>Remember that any of those anonymous functions can also be written as “regular” functions, so you can write a function like this:</p>
<pre><code class="language-scala">def toUpper(s: String): String = s.toUpperCase
</code></pre>
<p>and then pass it into <code>map</code> like this:</p>
<pre><code class="language-scala">List(&quot;foo&quot;, &quot;bar&quot;).map(toUpper)
</code></pre>
<p>or this:</p>
<pre><code class="language-scala">List(&quot;foo&quot;, &quot;bar&quot;).map(s =&gt; toUpper(s))
</code></pre>
<p>Those examples that use a “regular” function are equivalent to these anonymous function examples:</p>
<pre><code class="language-scala">List(&quot;foo&quot;, &quot;bar&quot;).map(s =&gt; s.toUpperCase)
List(&quot;foo&quot;, &quot;bar&quot;).map(_.toUpperCase)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: No Null Values
description: This lesson demonstrates the Scala Option, Some, and None classes, including how to use them instead of null values.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 47
outof: 54
previous-page: passing-functions-around
next-page: companion-objects</h2>
<p>Functional programming is like writing a series of algebraic equations, and because you don’t use null values in algebra, you don’t use null values in FP. That brings up an interesting question: In the situations where you might normally use a null value in Java/OOP code, what do you do?</p>
<p>Scala’s solution is to use constructs like the Option/Some/None classes. We’ll provide an introduction to the techniques in this lesson.</p>
<h2 id="a-first-example-1"><a class="header" href="#a-first-example-1">A first example</a></h2>
<p>While this first Option/Some/None example doesn’t deal with null values, it’s a good way to demonstrate the Option/Some/None classes, so we’ll start with it.</p>
<p>Imagine that you want to write a method to make it easy to convert strings to integer values, and you want an elegant way to handle the exceptions that can be thrown when your method gets a string like <code>&quot;foo&quot;</code> instead of something that converts to a number, like <code>&quot;1&quot;</code>. A first guess at such a function might look like this:</p>
<pre><code class="language-scala">def toInt(s: String): Int = {
    try {
        Integer.parseInt(s.trim)
    } catch {
        case e: Exception =&gt; 0
    }
}
</code></pre>
<p>The idea of this function is that if a string converts to an integer, you return the converted <code>Int</code>, but if the conversion fails you return 0. This might be okay for some purposes, but it’s not really accurate. For instance, the method might have received <code>&quot;0&quot;</code>, but it may have also received <code>&quot;foo&quot;</code> or <code>&quot;bar&quot;</code> or an infinite number of other strings. This creates a real problem: How do you know when the method really received a <code>&quot;0&quot;</code>, or when it received something else? The answer is that with this approach, there’s no way to know.</p>
<h2 id="using-optionsomenone"><a class="header" href="#using-optionsomenone">Using Option/Some/None</a></h2>
<p>Scala’s solution to this problem is to use a trio of classes known as <code>Option</code>, <code>Some</code>, and <code>None</code>. The <code>Some</code> and <code>None</code> classes are subclasses of <code>Option</code>, so the solution works like this:</p>
<ul>
<li>You declare that <code>toInt</code> returns an <code>Option</code> type</li>
<li>If <code>toInt</code> receives a string it <em>can</em> convert to an <code>Int</code>, you wrap the <code>Int</code> inside of a <code>Some</code></li>
<li>If <code>toInt</code> receives a string it <em>can’t</em> convert, it returns a <code>None</code></li>
</ul>
<p>The implementation of the solution looks like this:</p>
<pre><code class="language-scala">def toInt(s: String): Option[Int] = {
    try {
        Some(Integer.parseInt(s.trim))
    } catch {
        case e: Exception =&gt; None
    }
}
</code></pre>
<p>This code can be read as, “When the given string converts to an integer, return the integer wrapped in a <code>Some</code> wrapper, such as <code>Some(1)</code>. When the string can’t be converted to an integer, return a <code>None</code> value.”</p>
<p>Here are two REPL examples that demonstrate <code>toInt</code> in action:</p>
<pre><code class="language-scala">scala&gt; val a = toInt(&quot;1&quot;)
a: Option[Int] = Some(1)

scala&gt; val a = toInt(&quot;foo&quot;)
a: Option[Int] = None
</code></pre>
<p>As shown, the string <code>&quot;1&quot;</code> converts to <code>Some(1)</code>, and the string <code>&quot;foo&quot;</code> converts to <code>None</code>. This is the essence of the Option/Some/None approach. It’s used to handle exceptions (as in this example), and the same technique works for handling null values.</p>
<blockquote>
<p>You’ll find this approach used throughout Scala library classes, and in third-party Scala libraries.</p>
</blockquote>
<h2 id="being-a-consumer-of-toint"><a class="header" href="#being-a-consumer-of-toint">Being a consumer of toInt</a></h2>
<p>Now imagine that you’re a consumer of the <code>toInt</code> method. You know that the method returns a subclass of <code>Option[Int]</code>, so the question becomes, how do you work with these return types?</p>
<p>There are two main answers, depending on your needs:</p>
<ul>
<li>Use a <code>match</code> expression</li>
<li>Use a for-expression</li>
</ul>
<blockquote>
<p>There are other approaches, but these are the two main approaches, especially from an FP standpoint.</p>
</blockquote>
<h3 id="using-a-match-expression"><a class="header" href="#using-a-match-expression">Using a match expression</a></h3>
<p>One possibility is to use a <code>match</code> expression, which looks like this:</p>
<pre><code class="language-scala">toInt(x) match {
    case Some(i) =&gt; println(i)
    case None =&gt; println(&quot;That didn't work.&quot;)
}
</code></pre>
<p>In this example, if <code>x</code> can be converted to an <code>Int</code>, the first <code>case</code> statement is executed; if <code>x</code> can’t be converted to an <code>Int</code>, the second <code>case</code> statement is executed.</p>
<h3 id="using-foryield"><a class="header" href="#using-foryield">Using for/yield</a></h3>
<p>Another common solution is to use a for-expression — i.e., the for/yield combination that was shown earlier in this book. To demonstrate this, imagine that you want to convert three strings to integer values, and then add them together. The for/yield solution looks like this:</p>
<pre><code class="language-scala">val y = for {
    a &lt;- toInt(stringA)
    b &lt;- toInt(stringB)
    c &lt;- toInt(stringC)
} yield a + b + c
</code></pre>
<p>When that expression finishes running, <code>y</code> will be one of two things:</p>
<ul>
<li>If all three strings convert to integers, <code>y</code> will be a <code>Some[Int]</code>, i.e., an integer wrapped inside a <code>Some</code></li>
<li>If any of the three strings can’t be converted to an integer, <code>y</code> will be a <code>None</code></li>
</ul>
<p>You can test this for yourself in the Scala REPL. First, paste these three string variables into the REPL:</p>
<pre><code class="language-scala">val stringA = &quot;1&quot;
val stringB = &quot;2&quot;
val stringC = &quot;3&quot;
</code></pre>
<p>Next, paste the for-expression into the REPL. When you do that, you’ll see this result:</p>
<pre><code class="language-scala">scala&gt; val y = for {
     |     a &lt;- toInt(stringA)
     |     b &lt;- toInt(stringB)
     |     c &lt;- toInt(stringC)
     | } yield a + b + c
y: Option[Int] = Some(6)
</code></pre>
<p>As shown, <code>y</code> is bound to the value <code>Some(6)</code>.</p>
<p>To see the failure case, change any of those strings to something that won’t convert to an integer. When you do that, you’ll see that <code>y</code> is a <code>None</code>:</p>
<pre><code class="language-scala">y: Option[Int] = None
</code></pre>
<h2 id="options-can-be-thought-of-as-a-container-of-0-or-1-items"><a class="header" href="#options-can-be-thought-of-as-a-container-of-0-or-1-items">Options can be thought of as a container of 0 or 1 items</a></h2>
<p>One good way to think about the <code>Option</code> classes is that they represent a <em>container</em>, more specifically a container that has either zero or one item inside:</p>
<ul>
<li><code>Some</code> is a container with one item in it</li>
<li><code>None</code> is a container, but it has nothing in it</li>
</ul>
<blockquote>
<p>If you prefer to think of the Option classes as being like a box, <code>None</code> is a little like getting an empty box for a birthday gift.</p>
</blockquote>
<h2 id="using-foreach"><a class="header" href="#using-foreach">Using foreach</a></h2>
<p>Because <code>Some</code> and <code>None</code> can be thought of containers, they can be further thought of as being like collections classes. As a result, they have all of the methods you’d expect from a collection class, including <code>map</code>, <code>filter</code>, <code>foreach</code>, etc.</p>
<p>This raises an interesting question: What will these two values print, if anything?</p>
<pre><code class="language-scala">toInt(&quot;1&quot;).foreach(println)
toInt(&quot;x&quot;).foreach(println)
</code></pre>
<p>The answer is that the first example prints the number <code>1</code>, and the second example doesn’t print anything. The first example prints <code>1</code> because:</p>
<ul>
<li>toInt(&quot;1&quot;) evaluates to <code>Some(1)</code></li>
<li>The expression evaluates to <code>Some(1).foreach(println)</code></li>
<li>The <code>foreach</code> method on the <code>Some</code> class knows how to reach inside the <code>Some</code> container and extract the value (<code>1</code>) that’s inside it, so it passes that value to <code>println</code></li>
</ul>
<p>Similarly, the second example prints nothing because:</p>
<ul>
<li><code>toInt(&quot;x&quot;)</code> evaluates to <code>None</code></li>
<li>The <code>foreach</code> method on the <code>None</code> class knows that <code>None</code> doesn’t contain anything, so it does nothing</li>
</ul>
<blockquote>
<p>Again, <code>None</code> is just an empty container.</p>
</blockquote>
<p>Somewhere in Scala’s history, someone noted that the first example (the <code>Some</code>) represents the “Happy Path” of Option/Some/None approach, and the second example (the <code>None</code>) represents the “Unhappy Path.” <em>But</em>, despite having two different possible outcomes, the cool thing about the approach is that the code you write to handle an <code>Option</code> looks exactly the same in both cases. The <code>foreach</code> examples look like this:</p>
<pre><code class="language-scala">toInt(&quot;1&quot;).foreach(println)
toInt(&quot;x&quot;).foreach(println)
</code></pre>
<p>And the for-expression looks like this:</p>
<pre><code class="language-scala">val y = for {
    a &lt;- toInt(stringA)
    b &lt;- toInt(stringB)
    c &lt;- toInt(stringC)
} yield a + b + c
</code></pre>
<p>You only have to write one piece of code to handle both the Happy and Unhappy Paths, and that simplifies your code. The only time you have to think about whether you got a <code>Some</code> or a <code>None</code> is when you finally handle the result value in a <code>match</code> expression, like this:</p>
<pre><code class="language-scala">toInt(x) match {
    case Some(i) =&gt; println(i)
    case None =&gt; println(&quot;That didn't work.&quot;)
}
</code></pre>
<h2 id="using-option-to-replace-null-values"><a class="header" href="#using-option-to-replace-null-values">Using Option to replace null values</a></h2>
<p>Another place where a null value can silently creep into your code is with a class like this:</p>
<pre><code class="language-scala">class Address (
    var street1: String,
    var street2: String,
    var city: String, 
    var state: String, 
    var zip: String
)
</code></pre>
<p>While every address on Earth has a <code>street1</code> value, the <code>street2</code> value is optional. As a result, that class is subject to this type of abuse:</p>
<pre><code class="language-scala">val santa = new Address(
    &quot;1 Main Street&quot;,
    null,               // &lt;-- D'oh! A null value!
    &quot;North Pole&quot;,
    &quot;Alaska&quot;,
    &quot;99705&quot;
)
</code></pre>
<p>To handle situations like this, developers tend to use null values or empty strings, both of which are hacks to work around the main problem: <code>street2</code> is an <em>optional</em> field. In Scala — and other modern languages — the correct solution is to declare up front that <code>street2</code> is optional:</p>
<pre><code class="language-scala">class Address (
    var street1: String,
    var street2: Option[String],
    var city: String, 
    var state: String, 
    var zip: String
)
</code></pre>
<p>With that definition, developers can write more accurate code like this:</p>
<pre><code class="language-scala">val santa = new Address(
    &quot;1 Main Street&quot;,
    None,
    &quot;North Pole&quot;,
    &quot;Alaska&quot;,
    &quot;99705&quot;
)
</code></pre>
<p>or this:</p>
<pre><code class="language-scala">val santa = new Address(
    &quot;123 Main Street&quot;,
    Some(&quot;Apt. 2B&quot;),
    &quot;Talkeetna&quot;,
    &quot;Alaska&quot;,
    &quot;99676&quot;
)
</code></pre>
<p>Once you have an optional field like this, you work with it as shown in the previous examples: With <code>match</code> expressions, <code>for</code> expressions, and other built-in methods like <code>foreach</code>.</p>
<h2 id="option-isnt-the-only-solution"><a class="header" href="#option-isnt-the-only-solution">Option isn’t the only solution</a></h2>
<p>This lesson focused on the Option/Some/None solution, but Scala has a few other alternatives. For example, a trio of classes known as Try/Success/Failure work in the same manner, but a) you primarily use these classes when code can throw exceptions, and b) the <code>Failure</code> class gives you access to the exception message. For example, Try/Success/Failure is commonly used when writing methods that interact with files, databases, and internet services, as those functions can easily throw exceptions. These classes are demonstrated in the Functional Error Handling lesson that follows.</p>
<h2 id="key-points-2"><a class="header" href="#key-points-2">Key points</a></h2>
<p>This lesson was a little longer than the others, so here’s a quick review of the key points:</p>
<ul>
<li>Functional programmers don’t use null values</li>
<li>A main replacement for null values is to use the Option/Some/None classes</li>
<li>Common ways to work with Option values are <code>match</code> and <code>for</code> expressions</li>
<li>Options can be thought of as containers of one item (<code>Some</code>) and no items (<code>None</code>)</li>
<li>You can also use Options when defining constructor parameters</li>
</ul>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See also</a></h2>
<ul>
<li>Tony Hoare invented the null reference in 1965, and refers to it as his “<a href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions">billion dollar mistake</a>.”</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Companion Objects
description: This lesson provides an introduction to 'companion objects' in Scala, including writing 'apply' and 'unapply' methods.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 48
outof: 54
previous-page: no-null-values
next-page: case-classes</h2>
<p>A <em>companion object</em> in Scala is an <code>object</code> that’s declared in the same file as a <code>class</code>, and has the same name as the class. For instance, when the following code is saved in a file named <em>Pizza.scala</em>, the <code>Pizza</code> object is considered to be a companion object to the <code>Pizza</code> class:</p>
<pre><code class="language-scala">class Pizza {
}

object Pizza {
}
</code></pre>
<p>This has several benefits. First, a companion object and its class can access each other’s private members (fields and methods). This means that the <code>printFilename</code> method in this class will work because it can access the <code>HiddenFilename</code> field in its companion object:</p>
<pre><code class="language-scala">class SomeClass {
    def printFilename() = {
        println(SomeClass.HiddenFilename)
    }
}

object SomeClass {
    private val HiddenFilename = &quot;/tmp/foo.bar&quot;
}
</code></pre>
<p>A companion object offers much more functionality than this, and we’ll demonstrate a few of its most important features in the rest of this lesson.</p>
<h2 id="creating-new-instances-without-the-new-keyword"><a class="header" href="#creating-new-instances-without-the-new-keyword">Creating new instances without the <code>new</code> keyword</a></h2>
<p>You probably noticed in some examples in this book that you can create new instances of certain classes without having to use the <code>new</code> keyword before the class name, as in this example:</p>
<pre><code class="language-scala">val zenMasters = List(
    Person(&quot;Nansen&quot;),
    Person(&quot;Joshu&quot;)
)
</code></pre>
<p>This functionality comes from the use of companion objects. What happens is that when you define an <code>apply</code> method in a companion object, it has a special meaning to the Scala compiler. There’s a little syntactic sugar baked into Scala that lets you type this code:</p>
<pre><code class="language-scala">val p = Person(&quot;Fred Flinstone&quot;)
</code></pre>
<p>and during the compilation process the compiler turns that code into this code:</p>
<pre><code class="language-scala">val p = Person.apply(&quot;Fred Flinstone&quot;)
</code></pre>
<p>The <code>apply</code> method in the companion object acts as a <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method</a>, and Scala’s syntactic sugar lets you use the syntax shown, creating new class instances without using the <code>new</code> keyword.</p>
<h3 id="enabling-that-functionality"><a class="header" href="#enabling-that-functionality">Enabling that functionality</a></h3>
<p>To demonstrate how this feature works, here’s a class named <code>Person</code> along with an <code>apply</code> method in its companion object:</p>
<pre><code class="language-scala">class Person {
    var name = &quot;&quot;
}

object Person {
    def apply(name: String): Person = {
        var p = new Person
        p.name = name
        p
    }
}
</code></pre>
<p>To test this code, paste both the class and the object in the Scala REPL at the same time using this technique:</p>
<ul>
<li>Start the Scala REPL from your command line (with the <code>scala</code> command)</li>
<li>Type <code>:paste</code> and press the [Enter] key</li>
<li>The REPL should respond with this text:</li>
</ul>
<pre><code class="language-scala">// Entering paste mode (ctrl-D to finish)
</code></pre>
<ul>
<li>Now paste both the class and object into the REPL at the same time</li>
<li>Press Ctrl-D to finish the “paste” process</li>
</ul>
<p>When that process works you should see this output in the REPL:</p>
<pre><code>defined class Person
defined object Person
</code></pre>
<blockquote>
<p>The REPL requires that a class and its companion object be entered at the same time with this technique.</p>
</blockquote>
<p>Now you can create a new instance of the <code>Person</code> class like this:</p>
<pre><code class="language-scala">val p = Person.apply(&quot;Fred Flinstone&quot;)
</code></pre>
<p>That code directly calls <code>apply</code> in the companion object. More importantly, you can also create a new instance like this:</p>
<pre><code class="language-scala">val p = Person(&quot;Fred Flinstone&quot;)
</code></pre>
<p>and this:</p>
<pre><code class="language-scala">val zenMasters = List(
    Person(&quot;Nansen&quot;),
    Person(&quot;Joshu&quot;)
)
</code></pre>
<p>To be clear, what happens in this process is:</p>
<ul>
<li>You type something like <code>val p = Person(&quot;Fred&quot;)</code></li>
<li>The Scala compiler sees that there is no <code>new</code> keyword before <code>Person</code></li>
<li>The compiler looks for an <code>apply</code> method in the companion object of the <code>Person</code> class that matches the type signature you entered</li>
<li>If it finds an <code>apply</code> method, it uses it; if it doesn’t, you get a compiler error</li>
</ul>
<h3 id="creating-multiple-constructors"><a class="header" href="#creating-multiple-constructors">Creating multiple constructors</a></h3>
<p>You can create multiple <code>apply</code> methods in a companion object to provide multiple constructors. The following code shows how to create both one- and two-argument constructors. Because we introduced <code>Option</code> values in the previous lesson, this example also shows how to use <code>Option</code> in a situation like this:</p>
<pre><code class="language-scala">class Person {
    var name: Option[String] = None
    var age: Option[Int] = None
    override def toString = s&quot;$name, $age&quot;
}

object Person {

    // a one-arg constructor
    def apply(name: Option[String]): Person = {
        var p = new Person
        p.name = name
        p
    }

    // a two-arg constructor
    def apply(name: Option[String], age: Option[Int]): Person = {
        var p = new Person
        p.name = name
        p.age = age
        p
    }

}
</code></pre>
<p>If you paste that code into the REPL as before, you’ll see that you can create new <code>Person</code> instances like this:</p>
<pre><code class="language-scala">val p1 = Person(Some(&quot;Fred&quot;))
val p2 = Person(None)

val p3 = Person(Some(&quot;Wilma&quot;), Some(33))
val p4 = Person(Some(&quot;Wilma&quot;), None)
</code></pre>
<p>When you print those values you’ll see these results:</p>
<pre><code class="language-scala">val p1: Person = Some(Fred), None
val p2: Person = None, None
val p3: Person = Some(Wilma), Some(33)
val p4: Person = Some(Wilma), None
</code></pre>
<blockquote>
<p>When running tests like this, it’s best to clear the REPL’s memory. To do this, use the <code>:reset</code> command inside the REPL before using the <code>:paste</code> command.</p>
</blockquote>
<h2 id="adding-an-unapply-method"><a class="header" href="#adding-an-unapply-method">Adding an <code>unapply</code> method</a></h2>
<p>Just as adding an <code>apply</code> method in a companion object lets you <em>construct</em> new object instances, adding an <code>unapply</code> lets you <em>de-construct</em> object instances. We’ll demonstrate this with an example.</p>
<p>Here’s a different version of a <code>Person</code> class and a companion object:</p>
<pre><code class="language-scala">class Person(var name: String, var age: Int)

object Person {
    def unapply(p: Person): String = s&quot;${p.name}, ${p.age}&quot;
}
</code></pre>
<p>Notice that the companion object defines an <code>unapply</code> method. That method takes an input parameter of the type <code>Person</code>, and returns a <code>String</code>. To test the <code>unapply</code> method manually, first create a new <code>Person</code> instance:</p>
<pre><code class="language-scala">val p = new Person(&quot;Lori&quot;, 29)
</code></pre>
<p>Then test <code>unapply</code> like this:</p>
<pre><code class="language-scala">val result = Person.unapply(p)
</code></pre>
<p>This is what the <code>unapply</code> result looks like in the REPL:</p>
<pre><code>scala&gt; val result = Person.unapply(p)
result: String = Lori, 29
</code></pre>
<p>As shown, <code>unapply</code> de-constructs the <code>Person</code> instance it’s given. In Scala, when you put an <code>unapply</code> method in a companion object, it’s said that you’ve created an <em>extractor</em> method, because you’ve created a way to extract the fields out of the object.</p>
<h3 id="unapply-can-return-different-types"><a class="header" href="#unapply-can-return-different-types"><code>unapply</code> can return different types</a></h3>
<p>In that example <code>unapply</code> returns a <code>String</code>, but you can write it to return anything. Here’s an example that returns the two fields in a tuple:</p>
<pre><code class="language-scala">class Person(var name: String, var age: Int)

object Person {
    def unapply(p: Person): Tuple2[String, Int] = (p.name, p.age)
}
</code></pre>
<p>Here’s what that method looks like in the REPL:</p>
<pre><code class="language-scala">scala&gt; val result = Person.unapply(p)
result: (String, Int) = (Lori,29)
</code></pre>
<p>Because this <code>unapply</code> method returns the class fields as a tuple, you can also do this:</p>
<pre><code class="language-scala">scala&gt; val (name, age) = Person.unapply(p)
name: String = Lori
age: Int = 29
</code></pre>
<h3 id="unapply-extractors-in-the-real-world"><a class="header" href="#unapply-extractors-in-the-real-world"><code>unapply</code> extractors in the real world</a></h3>
<p>A benefit of using <code>unapply</code> to create an extractor is that if you follow the proper Scala conventions, they enable a convenient form of pattern-matching in match expressions.</p>
<p>We’ll discuss that more in the next lesson, but as you’ll see, the story gets even better: You rarely need to write an <code>unapply</code> method yourself. Instead, what happens is that you get <code>apply</code> and <code>unapply</code> methods for free when you create your classes as <em>case classes</em> rather than as the “regular” Scala classes you’ve seen so far. We’ll dive into case classes in the next lesson.</p>
<h2 id="key-points-3"><a class="header" href="#key-points-3">Key points</a></h2>
<p>The key points of this lesson are:</p>
<ul>
<li>A <em>companion object</em> is an <code>object</code> that’s declared in the same file as a <code>class</code>, and has the same name as the class</li>
<li>A companion object and its class can access each other’s private members</li>
<li>A companion object’s <code>apply</code> method lets you create new instances of a class without using the <code>new</code> keyword</li>
<li>A companion object’s <code>unapply</code> method lets you de-construct an instance of a class into its individual components</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: Case Classes
description: This lesson provides an introduction to 'case classes' in Scala.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 49
outof: 54
previous-page: companion-objects
next-page: case-objects</h2>
<p>Another Scala feature that provides support for functional programming is the <em>case class</em>. A case class has all of the functionality of a regular class, and more. When the compiler sees the <code>case</code> keyword in front of a <code>class</code>, it generates code for you, with the following benefits:</p>
<ul>
<li>Case class constructor parameters are public <code>val</code> fields by default, so accessor methods are generated for each parameter.</li>
<li>An <code>apply</code> method is created in the companion object of the class, so you don’t need to use the <code>new</code> keyword to create a new instance of the class.</li>
<li>An <code>unapply</code> method is generated, which lets you use case classes in more ways in <code>match</code> expressions.</li>
<li>A <code>copy</code> method is generated in the class. You may not use this feature in Scala/OOP code, but it’s used all the time in Scala/FP.</li>
<li><code>equals</code> and <code>hashCode</code> methods are generated, which let you compare objects and easily use them as keys in maps.</li>
<li>A default <code>toString</code> method is generated, which is helpful for debugging.</li>
</ul>
<p>These features are all demonstrated in the following sections.</p>
<h2 id="with-apply-you-dont-need-new"><a class="header" href="#with-apply-you-dont-need-new">With <code>apply</code> you don’t need <code>new</code></a></h2>
<p>When you define a class as a <code>case</code> class, you don’t have to use the <code>new</code> keyword to create a new instance:</p>
<pre><code class="language-scala">scala&gt; case class Person(name: String, relation: String)
defined class Person

// &quot;new&quot; not needed before Person
scala&gt; val christina = Person(&quot;Christina&quot;, &quot;niece&quot;)
christina: Person = Person(Christina,niece)
</code></pre>
<p>As discussed in the previous lesson, this works because a method named <code>apply</code> is generated inside <code>Person</code>’s companion object.</p>
<h2 id="no-mutator-methods"><a class="header" href="#no-mutator-methods">No mutator methods</a></h2>
<p>Case class constructor parameters are <code>val</code> fields by default, so an <em>accessor</em> method is generated for each parameter:</p>
<pre><code class="language-scala">scala&gt; christina.name
res0: String = Christina
</code></pre>
<p>But, <em>mutator</em> methods are not generated:</p>
<pre><code class="language-scala">// can't mutate the `name` field
scala&gt; christina.name = &quot;Fred&quot;
&lt;console&gt;:10: error: reassignment to val
       christina.name = &quot;Fred&quot;
                  ^
</code></pre>
<p>Because in FP you never mutate data structures, it makes sense that constructor fields default to <code>val</code>.</p>
<h2 id="an-unapply-method"><a class="header" href="#an-unapply-method">An <code>unapply</code> method</a></h2>
<p>In the previous lesson on companion objects you saw how to write <code>unapply</code> methods. A great thing about a case class is that it automatically generates an <code>unapply</code> method for your class, so you don’t have to write one.</p>
<p>To demonstrate this, imagine that you have this trait:</p>
<pre><code class="language-scala">trait Person {
    def name: String
}
</code></pre>
<p>Then, create these case classes to extend that trait:</p>
<pre><code class="language-scala">case class Student(name: String, year: Int) extends Person
case class Teacher(name: String, specialty: String) extends Person
</code></pre>
<p>Because those are defined as case classes — and they have built-in <code>unapply</code> methods — you can write a match expression like this:</p>
<pre><code class="language-scala">def getPrintableString(p: Person): String = p match {
    case Student(name, year) =&gt;
        s&quot;$name is a student in Year $year.&quot;
    case Teacher(name, whatTheyTeach) =&gt;
        s&quot;$name teaches $whatTheyTeach.&quot;
}
</code></pre>
<p>Notice these two patterns in the <code>case</code> statements:</p>
<pre><code class="language-scala">case Student(name, year) =&gt;
case Teacher(name, whatTheyTeach) =&gt;
</code></pre>
<p>Those patterns work because <code>Student</code> and <code>Teacher</code> are defined as case classes that have <code>unapply</code> methods whose type signature conforms to a certain standard. Technically, the specific type of pattern matching shown in these examples is known as a <em>constructor pattern</em>.</p>
<blockquote>
<p>The Scala standard is that an <code>unapply</code> method returns the case class constructor fields in a tuple that’s wrapped in an <code>Option</code>. The “tuple” part of the solution was shown in the previous lesson.</p>
</blockquote>
<p>To show how that code works, create an instance of <code>Student</code> and <code>Teacher</code>:</p>
<pre><code class="language-scala">val s = Student(&quot;Al&quot;, 1)
val t = Teacher(&quot;Bob Donnan&quot;, &quot;Mathematics&quot;)
</code></pre>
<p>Next, this is what the output looks like in the REPL when you call <code>getPrintableString</code> with those two instances:</p>
<pre><code class="language-scala">scala&gt; getPrintableString(s)
res0: String = Al is a student in Year 1.

scala&gt; getPrintableString(t)
res1: String = Bob Donnan teaches Mathematics.
</code></pre>
<blockquote>
<p>All of this content on <code>unapply</code> methods and extractors is a little advanced for an introductory book like this, but because case classes are an important FP topic, it seems better to cover them, rather than skipping over them.</p>
</blockquote>
<h2 id="copy-method"><a class="header" href="#copy-method"><code>copy</code> method</a></h2>
<p>A <code>case</code> class also has an automatically-generated <code>copy</code> method that’s extremely helpful when you need to perform the process of a) cloning an object and b) updating one or more of the fields during the cloning process. As an example, this is what the process looks like in the REPL:</p>
<pre><code class="language-scala">scala&gt; case class BaseballTeam(name: String, lastWorldSeriesWin: Int)
defined class BaseballTeam

scala&gt; val cubs1908 = BaseballTeam(&quot;Chicago Cubs&quot;, 1908)
cubs1908: BaseballTeam = BaseballTeam(Chicago Cubs,1908)

scala&gt; val cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2016)
cubs2016: BaseballTeam = BaseballTeam(Chicago Cubs,2016)
</code></pre>
<p>As shown, when you use the <code>copy</code> method, all you have to do is supply the names of the fields you want to modify during the cloning process.</p>
<p>Because you never mutate data structures in FP, this is how you create a new instance of a class from an existing instance. This process can be referred to as, “update as you copy.”</p>
<h2 id="equals-and-hashcode-methods"><a class="header" href="#equals-and-hashcode-methods"><code>equals</code> and <code>hashCode</code> methods</a></h2>
<p>Case classes also have automatically-generated <code>equals</code> and <code>hashCode</code> methods, so instances can be compared:</p>
<pre><code class="language-scala">scala&gt; case class Person(name: String, relation: String)
defined class Person

scala&gt; val christina = Person(&quot;Christina&quot;, &quot;niece&quot;)
christina: Person = Person(Christina,niece)

scala&gt; val hannah = Person(&quot;Hannah&quot;, &quot;niece&quot;)
hannah: Person = Person(Hannah,niece)

scala&gt; christina == hannah
res1: Boolean = false
</code></pre>
<p>These methods also let you easily use your objects in collections like sets and maps.</p>
<h2 id="tostring-methods"><a class="header" href="#tostring-methods"><code>toString</code> methods</a></h2>
<p>Finally, <code>case</code> classes also have a good default <code>toString</code> method implementation, which at the very least is helpful when debugging code:</p>
<pre><code class="language-scala">scala&gt; christina
res0: Person = Person(Christina,niece)
</code></pre>
<h2 id="the-biggest-advantage"><a class="header" href="#the-biggest-advantage">The biggest advantage</a></h2>
<p>While all of these features are great benefits to functional programming, as they write in the book, <a href="https://www.amazon.com/Programming-Scala-Updated-2-12/dp/0981531687/">Programming in Scala</a> (Odersky, Spoon, and Venners), “the biggest advantage of case classes is that they support pattern matching.” Pattern matching is a major feature of FP languages, and Scala’s case classes provide a simple way to implement pattern matching in match expressions and other areas.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Case Objects
description: This lesson introduces Scala 'case objects', which are used to create singletons with a few additional features.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 50
outof: 54
previous-page: case-classes
next-page: functional-error-handling</h2>
<p>Before we jump into <em>case objects</em>, we should provide a little background on “regular” Scala objects. As we mentioned early in this book, you use a Scala <code>object</code> when you want to create a singleton object. As <a href="%7B%7Bsite.baseurl%7D%7D/tour/singleton-objects.html">the documentation states</a>, “Methods and values that aren’t associated with individual instances of a class belong in singleton objects, denoted by using the keyword <code>object</code> instead of <code>class</code>.”</p>
<p>A common example of this is when you create a “utilities” object, such as this one:</p>
<pre><code class="language-scala">object PizzaUtils {
    def addTopping(p: Pizza, t: Topping): Pizza = ...
    def removeTopping(p: Pizza, t: Topping): Pizza = ...
    def removeAllToppings(p: Pizza): Pizza = ...
}
</code></pre>
<p>Or this one:</p>
<pre><code class="language-scala">object FileUtils {
    def readTextFileAsString(filename: String): Try[String] = ...
    def copyFile(srcFile: File, destFile: File): Try[Boolean] = ...
    def readFileToByteArray(file: File): Try[Array[Byte]] = ...
    def readFileToString(file: File): Try[String] = ...
    def readFileToString(file: File, encoding: String): Try[String] = ...
    def readLines(file: File, encoding: String): Try[List[String]] = ...
}
</code></pre>
<p>This is a common way of using the Scala <code>object</code> construct.</p>
<h2 id="case-objects"><a class="header" href="#case-objects">Case objects</a></h2>
<p>A <code>case object</code> is like an <code>object</code>, but just like a case class has more features than a regular class, a case object has more features than a regular object. Its features include:</p>
<ul>
<li>It’s serializable</li>
<li>It has a default <code>hashCode</code> implementation</li>
<li>It has an improved <code>toString</code> implementation</li>
</ul>
<p>Because of these features, case objects are primarily used in two places (instead of regular objects):</p>
<ul>
<li>When creating enumerations</li>
<li>When creating containers for “messages” that you want to pass between other objects (such as with the <a href="https://akka.io">Akka</a> actors library)</li>
</ul>
<h2 id="creating-enumerations-with-case-objects"><a class="header" href="#creating-enumerations-with-case-objects">Creating enumerations with case objects</a></h2>
<p>As we showed earlier in this book, you create enumerations in Scala like this:</p>
<pre><code class="language-scala">sealed trait Topping
case object Cheese extends Topping
case object Pepperoni extends Topping
case object Sausage extends Topping
case object Mushrooms extends Topping
case object Onions extends Topping

sealed trait CrustSize
case object SmallCrustSize extends CrustSize
case object MediumCrustSize extends CrustSize
case object LargeCrustSize extends CrustSize

sealed trait CrustType
case object RegularCrustType extends CrustType
case object ThinCrustType extends CrustType
case object ThickCrustType extends CrustType
</code></pre>
<p>Then later in your code you use those enumerations like this:</p>
<pre><code class="language-scala">case class Pizza (
    crustSize: CrustSize,
    crustType: CrustType,
    toppings: Seq[Topping]
)
</code></pre>
<h2 id="using-case-objects-as-messages"><a class="header" href="#using-case-objects-as-messages">Using case objects as messages</a></h2>
<p>Another place where case objects come in handy is when you want to model the concept of a “message.” For example, imagine that you’re writing an application like Amazon’s Alexa, and you want to be able to pass around “speak”  messages like, “speak the enclosed text,” “stop speaking,”, “pause,” and “resume.” In Scala you create singleton objects for those messages like this:</p>
<pre><code class="language-scala">case class StartSpeakingMessage(textToSpeak: String)
case object StopSpeakingMessage
case object PauseSpeakingMessage
case object ResumeSpeakingMessage
</code></pre>
<p>Notice that <code>StartSpeakingMessage</code> is defined as a case <em>class</em> rather than a case <em>object</em>. This is because a case object can’t have any constructor parameters.</p>
<p>Given those messages, if Alexa was written using the Akka library, you’d find code like this in a “speak” class:</p>
<pre><code class="language-scala">class Speak extends Actor {
  def receive = {
    case StartSpeakingMessage(textToSpeak) =&gt;
        // code to speak the text
    case StopSpeakingMessage =&gt;
        // code to stop speaking
    case PauseSpeakingMessage =&gt;
        // code to pause speaking
    case ResumeSpeakingMessage =&gt;
        // code to resume speaking
  }
}
</code></pre>
<p>This is a good, safe way to pass messages around in Scala applications.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Functional Error Handling in Scala
description: This lesson takes a look at error handling with functional programming in Scala.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 51
outof: 54
previous-page: case-objects
next-page: concurrency-signpost</h2>
<p>Because functional programming is like algebra, there are no null values or exceptions. But of course you can still have exceptions when you try to access servers that are down or files that are missing, so what can you do? This lesson demonstrates the techniques of functional error handling in Scala.</p>
<h2 id="optionsomenone"><a class="header" href="#optionsomenone">Option/Some/None</a></h2>
<p>We already demonstrated one of the techniques to handle errors in Scala: The trio of classes named <code>Option</code>, <code>Some</code>, and <code>None</code>. Instead of writing a method like <code>toInt</code> to throw an exception or return a null value, you declare that the method returns an <code>Option</code>, in this case an <code>Option[Int]</code>:</p>
<pre><code class="language-scala">def toInt(s: String): Option[Int] = {
    try {
        Some(Integer.parseInt(s.trim))
    } catch {
        case e: Exception =&gt; None
    }
}
</code></pre>
<p>Later in your code you handle the result from <code>toInt</code> using <code>match</code> and <code>for</code> expressions:</p>
<pre><code class="language-scala">toInt(x) match {
    case Some(i) =&gt; println(i)
    case None =&gt; println(&quot;That didn't work.&quot;)
}

val y = for {
    a &lt;- toInt(stringA)
    b &lt;- toInt(stringB)
    c &lt;- toInt(stringC)
} yield a + b + c
</code></pre>
<p>These approaches were discussed in the “No Null Values” lesson, so we won’t repeat that discussion here.</p>
<h2 id="trysuccessfailure"><a class="header" href="#trysuccessfailure">Try/Success/Failure</a></h2>
<p>Another trio of classes named <code>Try</code>, <code>Success</code>, and <code>Failure</code> work just like <code>Option</code>, <code>Some</code>, and <code>None</code>, but with two nice features:</p>
<ul>
<li><code>Try</code> makes it very simple to catch exceptions</li>
<li><code>Failure</code> contains the exception</li>
</ul>
<p>Here’s the <code>toInt</code> method re-written to use these classes. First, import the classes into the current scope:</p>
<pre><code class="language-scala">import scala.util.{Try,Success,Failure}
</code></pre>
<p>After that, this is what <code>toInt</code> looks like with <code>Try</code>:</p>
<pre><code class="language-scala">def toInt(s: String): Try[Int] = Try {
    Integer.parseInt(s.trim)
}
</code></pre>
<p>As you can see, that’s quite a bit shorter than the Option/Some/None approach, and it can further be shortened to this:</p>
<pre><code class="language-scala">def toInt(s: String): Try[Int] = Try(Integer.parseInt(s.trim))
</code></pre>
<p>Both of those approaches are much shorter than the Option/Some/None approach.</p>
<p>The REPL demonstrates how this works. First, the success case:</p>
<pre><code class="language-scala">scala&gt; val a = toInt(&quot;1&quot;)
a: scala.util.Try[Int] = Success(1)
</code></pre>
<p>Second, this is what it looks like when <code>Integer.parseInt</code> throws an exception:</p>
<pre><code class="language-scala">scala&gt; val b = toInt(&quot;boo&quot;)
b: scala.util.Try[Int] = Failure(java.lang.NumberFormatException: For input string: &quot;boo&quot;)
</code></pre>
<p>As that output shows, the <code>Failure</code> that’s returned by <code>toInt</code> contains the reason for the failure, i.e., the exception.</p>
<p>There are quite a few ways to work with the results of a <code>Try</code> — including the ability to “recover” from the failure — but common approaches still involve using <code>match</code> and <code>for</code> expressions:</p>
<pre><code class="language-scala">toInt(x) match {
    case Success(i) =&gt; println(i)
    case Failure(s) =&gt; println(s&quot;Failed. Reason: $s&quot;)
}

val y = for {
    a &lt;- toInt(stringA)
    b &lt;- toInt(stringB)
    c &lt;- toInt(stringC)
} yield a + b + c
</code></pre>
<p>Note that when using a for-expression and everything works, it returns the value wrapped in a <code>Success</code>:</p>
<pre><code class="language-scala">scala.util.Try[Int] = Success(6)
</code></pre>
<p>Conversely, if it fails, it returns a <code>Failure</code>:</p>
<pre><code class="language-scala">scala.util.Try[Int] = Failure(java.lang.NumberFormatException: For input string: &quot;a&quot;)
</code></pre>
<h2 id="even-more-"><a class="header" href="#even-more-">Even more ...</a></h2>
<p>There are other classes that work in a similar manner, including Either/Left/Right in the Scala library, and other third-party libraries, but Option/Some/None and Try/Success/Failure are commonly used, and good to learn first.</p>
<p>You can use whatever you like, but Try/Success/Failure is generally used when dealing with code that can throw exceptions — because you almost always want to understand the exception — and Option/Some/None is used in other places, such as to avoid using null values.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: Concurrency
description: An introduction to concurrency in Scala.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 52
outof: 54
previous-page: functional-error-handling
next-page: futures</h2>
<p>In the next lesson you’ll see a primary tool for writing parallel and concurrent applications, the Scala <code>Future</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: section
layout: multipage-overview
title: Scala Futures
description: This page provides an introduction to Futures in Scala, including Future callback methods.
partof: scala_book
overview-name: Scala Book
discourse: true
num: 53
outof: 54
previous-page: concurrency-signpost
next-page: where-next</h2>
<p>When you want to write parallel and concurrent applications in Scala, you <em>could</em> still use the native Java <code>Thread</code> — but the Scala <a href="https://www.scala-lang.org/api/current/scala/concurrent/Future$.html">Future</a> makes parallel/concurrent programming much simpler, and it’s preferred.</p>
<p>Here’s a description of <code>Future</code> from its Scaladoc:</p>
<blockquote>
<p>“A Future represents a value which may or may not <em>currently</em> be available, but will be available at some point, or an exception if that value could not be made available.” </p>
</blockquote>
<h3 id="thinking-in-futures"><a class="header" href="#thinking-in-futures">Thinking in futures</a></h3>
<p>To help demonstrate this, in single-threaded programming you bind the result of a function call to a variable like this:</p>
<pre><code class="language-scala">def aShortRunningTask(): Int = 42
val x = aShortRunningTask
</code></pre>
<p>With code like that, the value <code>42</code> is bound to the variable <code>x</code> immediately.</p>
<p>When you’re working with a <code>Future</code>, the assignment process looks similar:</p>
<pre><code class="language-scala">def aLongRunningTask(): Future[Int] = ???
val x = aLongRunningTask
</code></pre>
<p>But because <code>aLongRunningTask</code> takes an indeterminate amount of time to return, the value in <code>x</code> may or may not be <em>currently</em> available, but it will be available at some point (in the future).</p>
<p>Another important point to know about futures is that they’re intended as a one-shot, “Handle this relatively slow computation on some other thread, and call me back with a result when you’re done” construct. (As a point of comparison, <a href="https://akka.io">Akka</a> actors are intended to run for a long time and respond to many requests during their lifetime, but each future you create is intended to be run only once.)</p>
<p>In this lesson you’ll see how to use futures, including how to run multiple futures in parallel and combine their results in a for-expression, along with other methods that are used to handle the value in a future once it returns.</p>
<blockquote>
<p>Tip: If you’re just starting to work with futures and find the name <code>Future</code> to be confusing in the following examples, replace it with the name <code>ConcurrentResult</code>, which might be easier to understand initially.</p>
</blockquote>
<h2 id="source-code"><a class="header" href="#source-code">Source code</a></h2>
<p>You can find the source code for this lesson at this URL:</p>
<ul>
<li><a href="https://github.com/alvinj/HelloScalaFutures">github.com/alvinj/HelloScalaFutures</a></li>
</ul>
<h2 id="an-example-in-the-repl"><a class="header" href="#an-example-in-the-repl">An example in the REPL</a></h2>
<p>A Scala <code>Future</code> is used to create a temporary pocket of concurrency that you use for one-shot needs. You typically use it when you need to call an algorithm that runs an indeterminate amount of time — such as calling a web service or executing a long-running algorithm — so you therefore want to run it off of the main thread.</p>
<p>To demonstrate how this works, let’s start with an example of a <code>Future</code> in the Scala REPL. First, paste in these <code>import</code> statements:</p>
<pre><code class="language-scala">import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.{Failure, Success}
</code></pre>
<p>Now, you’re ready to create a future. For example, here’s a future that sleeps for ten seconds and then returns the value <code>42</code>:</p>
<pre><code class="language-scala">scala&gt; val a = Future { Thread.sleep(10*1000); 42 }
a: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)
</code></pre>
<p>While that’s a simple example, it shows the basic approach: Just construct a new <code>Future</code> with your long-running algorithm.</p>
<p>Because a <code>Future</code> has a <code>map</code> function, you use it as usual:</p>
<pre><code class="language-scala">scala&gt; val b = a.map(_ * 2)
b: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)
</code></pre>
<p>Initially this shows <code>Future(&lt;not completed&gt;)</code>, but if you check <code>b</code>’s value you’ll see that it eventually contains the expected result of <code>84</code>:</p>
<pre><code class="language-scala">scala&gt; b
res1: scala.concurrent.Future[Int] = Future(Success(84))
</code></pre>
<p>Notice that the <code>84</code> you expected is wrapped in a <code>Success</code>, which is further wrapped in a <code>Future</code>. This is a key point to know: The value in a <code>Future</code> is always an instance of one of the <code>Try</code> types: <code>Success</code> or <code>Failure</code>. Therefore, when working with the result of a future, use the usual <code>Try</code>-handling techniques, or one of the other <code>Future</code> callback methods.</p>
<p>One commonly used callback method is <code>onComplete</code>, which takes a <a href="https://alvinalexander.com/scala/how-to-define-use-partial-functions-in-scala-syntax-examples">partial function</a> in which you should handle the <code>Success</code> and <code>Failure</code> cases, like this:</p>
<pre><code class="language-scala">a.onComplete {
    case Success(value) =&gt; println(s&quot;Got the callback, value = $value&quot;)
    case Failure(e) =&gt; e.printStackTrace
}
</code></pre>
<p>When you paste that code in the REPL you’ll see the result:</p>
<pre><code class="language-scala">Got the callback, value = 42
</code></pre>
<p>There are other ways to process the results from futures, and the most common methods are listed later in this lesson.</p>
<h2 id="an-example-application"><a class="header" href="#an-example-application">An example application</a></h2>
<p>The following application (<code>App</code>) provides an introduction to using multiple futures. It shows several key points about how to work with futures:</p>
<ul>
<li>How to create futures</li>
<li>How to combine multiple futures in a <code>for</code> expression to obtain a single result</li>
<li>How to work with that result once you have it</li>
</ul>
<h3 id="a-potentially-slow-running-method"><a class="header" href="#a-potentially-slow-running-method">A potentially slow-running method</a></h3>
<p>First, imagine you have a method that accesses a web service to get the current price of a stock. Because it’s a web service it can be slow to return, and even fail. As a result, you create a method to run as a <code>Future</code>. It takes a stock symbol as an input parameter and returns the stock price as a <code>Double</code> inside a <code>Future</code>, so its signature looks like this:</p>
<pre><code class="language-scala">def getStockPrice(stockSymbol: String): Future[Double] = ???
</code></pre>
<p>To keep this tutorial simple we won’t access a real web service, so we’ll mock up a method that has a random run time before returning a result:</p>
<pre><code class="language-scala">def getStockPrice(stockSymbol: String): Future[Double] = Future {
    val r = scala.util.Random
    val randomSleepTime = r.nextInt(3000)
    val randomPrice = r.nextDouble * 1000
    sleep(randomSleepTime)
    randomPrice
}
</code></pre>
<p>That method sleeps a random time up to 3000 ms, and also returns a random stock price. Notice how simple it is to create a method that runs as a <code>Future</code>: Just pass a block of code into the <code>Future</code> constructor to create the method body.</p>
<p>Next, imagine that you’re instructed to get three stock prices in parallel, and return their results once all three return. To do so, you write code like this:</p>
<pre><code class="language-scala">package futures

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.util.{Failure, Success}

object MultipleFutures extends App {

    // use this to determine the “delta time” below
    val startTime = currentTime

    // (a) create three futures
    val aaplFuture = getStockPrice(&quot;AAPL&quot;)
    val amznFuture = getStockPrice(&quot;AMZN&quot;)
    val googFuture = getStockPrice(&quot;GOOG&quot;)

    // (b) get a combined result in a for-expression
    val result: Future[(Double, Double, Double)] = for {
        aapl &lt;- aaplFuture
        amzn &lt;- amznFuture
        goog &lt;- googFuture
    } yield (aapl, amzn, goog)

    // (c) do whatever you need to do with the results
    result.onComplete {
        case Success(x) =&gt; {
            val totalTime = deltaTime(startTime)
            println(s&quot;In Success case, time delta: ${totalTime}&quot;)
            println(s&quot;The stock prices are: $x&quot;)
        }
        case Failure(e) =&gt; e.printStackTrace
    }

    // important for a short parallel demo: you need to keep
    // the jvm’s main thread alive
    sleep(5000)

    def sleep(time: Long): Unit = Thread.sleep(time)

    // a simulated web service
    def getStockPrice(stockSymbol: String): Future[Double] = Future {
        val r = scala.util.Random
        val randomSleepTime = r.nextInt(3000)
        println(s&quot;For $stockSymbol, sleep time is $randomSleepTime&quot;)
        val randomPrice = r.nextDouble * 1000
        sleep(randomSleepTime)
        randomPrice
    }

    def currentTime = System.currentTimeMillis()
    def deltaTime(t0: Long) = currentTime - t0

}
</code></pre>
<p>Question: If everything truly runs in parallel, can you guess what the maximum value of the <code>totalTime</code> will be?</p>
<p>Answer: Because the three simulated web service calls do run in parallel, the total time should never be much longer than three seconds (3000ms). If they were run in series, the algorithm might run up to nine seconds.</p>
<p>This can be a fun little application to experiment with, so you’re encouraged to clone the Github project and run it before continuing this lesson. When you do so, first run it to make sure it works as expected, then change it as desired. If you run into problems, add <code>println</code> statements to the code so you can completely understand how it works.</p>
<blockquote>
<p>Tip: The Github repository for this lesson also contains a class named <code>MultipleFuturesWithDebugOutput</code> that contains the same code with a lot of debug <code>println</code> statements.</p>
</blockquote>
<h3 id="creating-the-futures"><a class="header" href="#creating-the-futures">Creating the futures</a></h3>
<p>Let’s walk through that code to see how it works. First, we create three futures with these lines of code:</p>
<pre><code class="language-scala">val aaplFuture = getStockPrice(&quot;AAPL&quot;)
val amznFuture = getStockPrice(&quot;AMZN&quot;)
val googFuture = getStockPrice(&quot;GOOG&quot;)
</code></pre>
<p>As you saw, <code>getStockPrice</code> is defined like this:</p>
<pre><code class="language-scala">def getStockPrice(stockSymbol: String): Future[Double] = Future { ...
</code></pre>
<p>If you remember the lesson on companion objects, the way the body of that method works is that the code in between the curly braces is passed into the <code>apply</code> method of <code>Future</code>’s companion object, so the compiler translates that code to something like this:</p>
<pre><code class="language-scala">def getStockPrice ... = Future.apply { method body here }
                               -----
</code></pre>
<p>An important thing to know about <code>Future</code> is that it <em>immediately</em> begins running the block of code inside the curly braces — it isn’t like the Java <code>Thread</code>, where you create an instance and later call its <code>start</code> method. You can see this very clearly in the debug output of the <code>MultipleFuturesWithDebugOutput</code> example, where the debug output in <code>getStockPrice</code> prints three times when the AAPL, AMZN, and GOOG futures are created, almost immediately after the application is started.</p>
<p>The three method calls eventually return the simulated stock prices. In fact, people often use the word <em>eventually</em> with futures because you typically use them when the return time of the algorithm is indeterminate: You don’t know when you’ll get a result back, you just hope to get a successful result back “eventually” (though you may also get an unsuccessful result).</p>
<h3 id="the-for-expression"><a class="header" href="#the-for-expression">The <code>for</code> expression</a></h3>
<p>The <code>for</code> expression in the application looks like this:</p>
<pre><code class="language-scala">val result: Future[(Double, Double, Double)] = for {
    aapl &lt;- aaplFuture
    amzn &lt;- amznFuture
    goog &lt;- googFuture
} yield (aapl, amzn, goog)
</code></pre>
<p>You can read this as, “Whenever <code>aapl</code>, <code>amzn</code>, and <code>goog</code> all return with their values, combine them in a tuple, and assign that value to the variable <code>result</code>.” As shown, <code>result</code> has the type <code>Future[(Double, Double, Double)]</code>, which is a tuple that contains three <code>Double</code> values, wrapped in a <code>Future</code> container.</p>
<p>It’s important to know that the application’s main thread doesn’t stop when <code>getStockPrice</code> is called, and it doesn’t stop at this for-expression either. In fact, if you print the result from <code>System.currentTimeMillis()</code> before and after the for-expression, you probably won’t see a difference of more than a few milliseconds. You can see that for yourself in the <code>MultipleFuturesWithDebugOutput</code> example.</p>
<h2 id="oncomplete"><a class="header" href="#oncomplete">onComplete</a></h2>
<p>The final part of the application looks like this:</p>
<pre><code class="language-scala">result.onComplete {
    case Success(x) =&gt; {
        val totalTime = deltaTime(startTime)
        println(s&quot;In Success case, time delta: ${totalTime}&quot;)
        println(s&quot;The stock prices are: $x&quot;)
    }
    case Failure(e) =&gt; e.printStackTrace
}
</code></pre>
<p><code>onComplete</code> is a method that’s available on a <code>Future</code>, and you use it to process the future’s result as a side effect. In the same way that the <code>foreach</code> method on collections classes returns <code>Unit</code> and is only used for side effects, <code>onComplete</code> returns <code>Unit</code> and you only use it for side effects like printing the results, updating a GUI, updating a database, etc.</p>
<p>You can read that code as, “Whenever <code>result</code> has a final value — i.e., after all of the futures return in the for-expression — come here. If everything returned successfully, run the <code>println</code> statement shown in the <code>Success</code> case. Otherwise, if an exception was thrown, go to the <code>Failure</code> case and print the exception’s stack trace.”</p>
<p>As that code implies, it’s completely possible that a <code>Future</code> may fail. For example, imagine that you call a web service, but the web service is down. That <code>Future</code> instance will contain an exception, so when you call <code>result.onComplete</code> like this, control will flow to the <code>Failure</code> case.</p>
<p>It’s important to note that just as the JVM’s main thread didn’t stop at the for-expression, it doesn’t block here, either. The code inside <code>onComplete</code> doesn’t execute until after the for-expression assigns a value to <code>result</code>.</p>
<h3 id="about-that-sleep-call"><a class="header" href="#about-that-sleep-call">About that <code>sleep</code> call</a></h3>
<p>A final point to note about small examples like this is that you need to have a <code>sleep</code> call at the end of your <code>App</code>:</p>
<pre><code class="language-scala">sleep(5000)
</code></pre>
<p>That call keeps the main thread of the JVM alive for five seconds. If you don’t include a call like this, the JVM’s main thread will exit before you get a result from the three futures, which are running on other threads. This isn’t usually a problem in the real world, but it’s needed for little demos like this.</p>
<h3 id="the-other-code"><a class="header" href="#the-other-code">The other code</a></h3>
<p>There are a few <code>println</code> statements in the code that use these methods:</p>
<pre><code class="language-scala">def currentTime = System.currentTimeMillis()
def deltaTime(t0: Long) = System.currentTimeMillis() - t0
</code></pre>
<p>There are only a few <code>println</code> statements in this code, so you can focus on how the main parts of the application works. However, as you’ll see in the Github code, there are many more <code>println</code> statements in the <code>MultipleFuturesWithDebugOutput</code> example so you can see exactly how futures work.</p>
<h2 id="other-future-methods"><a class="header" href="#other-future-methods">Other Future methods</a></h2>
<p>Futures have other methods that you can use. Common callback methods are:</p>
<ul>
<li><code>onComplete</code></li>
<li><code>onSuccess</code></li>
<li><code>onFailure</code></li>
</ul>
<p>In addition to those methods, futures have methods that you’ll find on Scala collections classes, including:</p>
<ul>
<li><code>filter</code></li>
<li><code>foreach</code></li>
<li><code>map</code></li>
</ul>
<p>Other useful and well-named methods include:</p>
<ul>
<li><code>andThen</code></li>
<li><code>fallbackTo</code></li>
<li><code>recoverWith</code></li>
</ul>
<p>These methods and many more details are discussed on the <a href="%7B%7Bsite.baseurl%7D%7D/overviews/core/futures.html">“Futures and Promises” page</a>.</p>
<h2 id="key-points-4"><a class="header" href="#key-points-4">Key points</a></h2>
<p>While this was a short introduction, hopefully those examples give you an idea of how Scala futures work. A few key points about futures are:</p>
<ul>
<li>You construct futures to run tasks off of the main thread</li>
<li>Futures are intended for one-shot, potentially long-running concurrent tasks that <em>eventually</em> return a value</li>
<li>A future starts running as soon as you construct it</li>
<li>A benefit of futures over threads is that they come with a variety of callback methods that simplify the process of working with concurrent threads,
including the handling of exceptions and thread management</li>
<li>Handle the result of a future with methods like <code>onComplete</code>, or combinator methods like <code>map</code>, <code>flatMap</code>, <code>filter</code>, <code>andThen</code>, etc.</li>
<li>The value in a <code>Future</code> is always an instance of one of the <code>Try</code> types: <code>Success</code> or <code>Failure</code></li>
<li>If you’re using multiple futures to yield a single result, you’ll often want to combine them in a for-expression</li>
</ul>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See also</a></h2>
<ul>
<li>A small demo GUI application named <em>Future Board</em> was written to accompany this lesson. It works a little like <a href="https://flipboard.com">Flipboard</a>, updating a group of news sources simultaneously. You can find the source code for Future Board in <a href="https://github.com/alvinj/FPFutures">this Github repository</a>.</li>
<li>While futures are intended for one-short, relatively short-lived concurrent processes, <a href="https://akka.io">Akka</a> is an “actor model” library for Scala, and provides a terrific way to implement long-running parallel processes. (If this term is new to you, an <em>actor</em> is a long-running process that runs in parallel to the main application thread, and responds to messages that are sent to it.)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>type: chapter
layout: multipage-overview
title: Where To Go Next
description: Where to go next after reading the Scala Book
partof: scala_book
overview-name: Scala Book
discourse: true
num: 54
outof: 54
previous-page: futures</h2>
<p>We hope you enjoyed this introduction to the Scala programming language, and we also hope we were able to share some of the beauty of the language.</p>
<p>As you continue working with Scala, you can find many more details at the <a href="%7B%7Bsite.baseurl%7D%7D/overviews/index.html">Guides and Overviews section</a> of our website.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
